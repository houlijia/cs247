[mpath,~,~] = fileparts(mfilename('fullpath'));
cd(mpath)
cd ..
trunk = pwd;
if strcmp(filesep(),'\')
    m_str = '\\trunk';
else
    m_str = sprintf('%strunk$', filesep());
end
if isempty(regexp(trunk, m_str, 'ONCE'))
    cd ..
end
cd ..
cd test_data
enc_opts = struct('process_color',true,...
  'msrmnt_mtrx',struct('type','SensingMatrixWH','args', struct('rnd_type',1)),...
  'blk_size',[72 88 2], 'blk_ovrlp',[0,0,0], ...
  'zero_ext_f',[0,0,0], 'zero_ext_b', [0,0,0], 'wrap_ext',[0,0,0],...
  'n_frames',2,...
  'msrmnt_input_ratio', {0.1,0.15,0.25}, 'random',struct('seed',1000),...
  'lossless_coder', '&CSVideoCodecInputOutputData.LLC_AC');
% enc_opts = struct('process_color',true,...
%   'msrmnt_mtrx',struct('type','SensingMatrixWH', 'args',struct()),...
%   'blk_size',[18 22 2], 'blk_ovrlp',[8, 4, 0], ...
%   'zero_ext_f',[4,0,3], 'zero_ext_b', [2,0,0], 'wrap_ext',[0,3,0],...
%   'n_frames',2,...
%   'msrmnt_input_ratio', {0.25,0.15}, 'random',struct('seed',1000),...
%   'lossless_coder', '&CSVideoCodecInputOutputData.LLC_AC');
anls_opts = [];
dec_opts = [];
% dec_opts = struct('disp',0, 'expand_level', VidBlocker.BLK_STT_INTRPLT);
% dec_opts = struct('disp',1, 'expand_level', VidBlocker.BLK_STT_RAW, ...
%   'beta_A0', 0.01, 'beta_D0', 0.01, 'max_int_iters', 10, 'sparsifier', ...
%   struct('args', struct('b_stt', VidBlocker.BLK_STT_INTRPLT)));
% dec_opts = struct('disp',1, 'expand_level', VidBlocker.BLK_STT_RAW, ...
%   'beta_A0', 0.01, 'beta_D0', 0.01, 'max_int_iters', 4, 'max_iters',20, 'sparsifier', ...
%   struct('args', struct('b_stt', VidBlocker.BLK_STT_INTRPLT)));
% dec_opts = struct('disp',0);
ids = struct('output','*','case','Mr<Mr>Q<Qm>,<Qa><Lc><Lg>');
% files_def = '<foreman_news_tcp_io.json';
files_def = brief_tcp_files_def('135.112.178.79:9000');
proc_opts = struct();
sml_io =  CSVidCodec.doSimulation(enc_opts,anls_opts,dec_opts,files_def, proc_opts);
