classdef FilesDef < handle
    % FilesDef is a class objects which can generate sets of file paths for
    % use in an experiment. Each set contains several files of different
    % types (input, output, etc.) generated from a base file name.  Each
    % type is characterized by an extension, which is appended to the base
    % file, and a place which is the directory in which the file is found
    % or placed.
    % The allowed file types are listed in std_types.
    %
    % The encoder directory, where encoding output files are stored is
    %
    %   output_dir[output_id]/case_dir[case_id]
    %
    % The decoder directory, where decoder output files are stored is
    %
    %   output_dir[output_id]/dec_dir[dec_id]/case_dir[case_id]
    %
    % if dec_dir is not specificed (usually when encoding is also done and
    % decoder output directory is the same as encoder output directory) the
    % decoder directory is the same as the encoder directory.
    
    % Each objects of this class defines a struct array
    % of data files.
    % The struct array is 'fields'.  files(n) is a set of files for
    % processing.  it may contain fields like 'input', 'encoded',
    % 'decoded', 'mat', etc. Each field in files(n) is a string represnting
    % the path to the specified file.
    
    properties (Constant, Access = private)
        % Symbolic names
        I=1; % Input
        E=2; % Encoder output
        D=3; % Decoder output
    end
    
    properties (Constant)
        % A struct array containing the common data typse and their standard
        % extensions. The fields 'place' and 'meaning' are mereley for
        % documentation:
        %  'type' is the file type name
        %  'ext' is the default extension for this file type
        %  'place' specifies where the file is expected to be
        %      placed:
        %         FilesDef.I - input,
        %         FilesDef.E - encoder output,
        %         FilesDef.D - decoder output,
        %  'meaning' - Explanation for documentation purposes
        
        std_types =cell2struct({...
            'input', '.json', FilesDef.I, 'Input: Raw video';...
            'enc_vid', '.csvid', FilesDef.E, ...
            'Encoder output, with CS data stream';...
            'output', 'o.yuv', FilesDef.D, 'Reconstructed video';...
            'txt', '.txt', FilesDef.D, 'Text summary of execution';...
            'mat', '.mat', FilesDef.D, 'Matlab state at end of execution';...
            'inp_mark', '.im.yuv', FilesDef.E, ...
            'Raw input file with motion markings';...
            'ref_mark', '.rm.yuv', FilesDef.D, ...
            'Same as inp_mark, but generate by decoder';...
            'dec_mark', '.dm.yuv', FilesDef.D, ...
            'Reconstructed video with motion markings';...
            'dec_slct_mark', '.dm_sl.yuv', FilesDef.D, ...
            'Selectively reconstructed video with motion markings';...
            'inp_anls', '.im.csv', FilesDef.E, ...
            'Analysis results of input (CSV)';...
            'inp_sav', '.im.sav.txt', FilesDef.E, ...
            'SAV of input (SAV)';...
            'inp_vanls', '.imv.csv', FilesDef.E, ...
            'Analysis results of input (CSV)';...
            'inp_vsav', '.imv.sav.txt', FilesDef.E, ...
            'SAV of input using whole vector shifts (SAV)';...
            'enc_anls', '.em.csv', FilesDef.E, ...
            'Analysis results of raw measurements (CSV)';...
            'enc_sav', '.em.sav.txt', FilesDef.E, ...
            'Analysis results of raw measurements (SAV)';...
            'dec_anls', '.dm.csv', FilesDef.D, ...
            'Analysis results of decoded measuremens (CSV)';...
            'dec_sav', '.dm.sav.txt', FilesDef.D, ...
            'Analysis results of decoded measuremens (SAV)';...
            'enc_pre_diff','.edff.yuv', FilesDef.E, ...
            'Input video after performing pre_diff';...
            'dec_pre_diff','.ddff.yuv', FilesDef.D, ...
            'Decoded video before reversing pre_diff';...
            'tst_pre_diff', '.dffo.yuv', FilesDef.E, ...
            'Test file generated by reverse reverse pre_diff on the enc_pre_diff data';...
            'err_pre_diff', '.dffe.yuv', FilesDef.D, ...
            'Difference between dec_pre_diff and enc_pre_diff';...
            'dec_ref_diff', '.dffr.yuv', FilesDef.D, ...
            'copy of the reference pre_diff fed to the decoder ';...
            'cnv_enc', '.cnv.csvid', FilesDef.D,... 
            'Compressed video file with converted compression';...
            'cnv_mat', '.cnv.mat', FilesDef.D, 'Matlab state after conversion'
            },...
            {'type', 'ext', 'place', 'meaning'},...
            2);
    end
    
    properties (Access=private)
        files;           % Base file names
        
        % The following structs have keys as field names
        types=struct(); % values are extensions.
        dirs_indx = struct(); % values are std_types.place values
        dirs = [];
        
        input_dir='';
        case_dir_pattern='';
        % These two structs have entries for output_dir, case_dir, dec_dir
        smbl = struct();  % Symbolic values (with place holders)
        actl = struct();  % Actual values (resolved)
    end
    
    methods
        % FilesDef - Constructor,  builds
        % files[] from spec.
        %
        % Input:
        % spec - can be one of the following
        %     - A struct with the fields:
        %        * 'types' - an array of structs defining the types of
        %          files. Each struct element has one field (type name)
        %          with a string value (type extension).
        %        * 'names - an array of strings with files base names
        %        * 'input_dir' (optional) - directory of input
        %        * 'output_dir' (optional) - output_dir directory
        %        * 'dec_dir' (optional) - directory of decoded files,
        %              ignored if params.do_enc is true
        %        * 'case_dir (optional) - if present specifies a
        %          subdirectory which is specific to all files of a
        %          specific case.
        %
        %     - A JSON string which resolves to the above struct
        %     - A string beginning with "<", inerpreted as the name of a
        %       file containing the JSON string.
        % params - (optional) a struct containing optional arguments, which
        %        can be:
        %    - fields: If present it is a cell array of strings
        %         specifying the keys which are needed. spec.types
        %         should contain all these keys. keys in spec.types which
        %         are not in fields are ignored (an error occurs if a
        %         string in params.fields is missing in spec.types).
        %    - do_enc: If present and true dec_dir is forced to be
        %         an empty string.
        %    - identifier - a struct suitable for calling specifyDirs(). If
        %         present files_def.specifyDirs(params.identifier) will be
        %         called.
        function files_def = FilesDef(spec, params)
            if nargin < 2
                params = struct();
            end
            
            % Parse spec
            info = ProcessingParams.read_opts(spec);
            if isstruct(info)
                info = ProcessingParams.eval_fields(info);
            end
                
            % Set directories
            files_def.input_dir = files_def.getDirNames(info, 'input_dir');
            files_def.case_dir_pattern = files_def.getDirNames(info,...
                'case_dir_pattern');
            for nm = {'output_dir', 'case_dir', 'dec_dir'}
                files_def.smbl.(nm{1}) = files_def.getDirNames(info, nm{1});
            end
            if isfield(params, 'do_enc') && params.do_enc
                files_def.smbl.dec_dir = '';
            end
            files_def.actl = files_def.smbl;
            
            % Special handling of case_dir_pattern
            if isempty(files_def.case_dir_pattern)
                files_def.case_dir_pattern = files_def.smbl.case_dir;
            end
            % Remove terminating file separator
            files_def.case_dir_pattern = ...
                files_def.case_dir_pattern(1:end-length(filesep()));
            
            if isfield(params, 'identifier')
                files_def.specifyDirs(params.identifier);
            end
            
            % check consistency of info.types
            if isfield(params, 'fields')
                [fields,exts,dir_types] = FilesDef.chkTypes(info.types, params.fields);
            else
                [fields,exts,dir_types] = FilesDef.chkTypes(info.types);
            end
            
            files_def.types = cell2struct(exts,fields,1);
            files_def.dirs_indx = cell2struct(dir_types,fields,1);
            files_def.files = info.names;
            
        end  % FilesDef
        
        % specifyDirs replaces place holder in paths by a given
        % identififier. The path can be one of 'output', 'case' or 'dec'.
        % Input:
        %   indentifier - a struct with any of the following fields:
        %       'output', 'case', 'dec'. The field values are the
        %       string identifiers to replace the place holder in the respective
        %       paths. If the field values are numeric/logical, a value of
        %       true causes no action and a value of 'false' delete the
        %       specified field (useful mainly for 'dec').
        %   place_holder (optional) - a struct with any of the following fields:
        %       'output', 'case', 'dec'. The field values are the place
        %       holder to be replaced. If the struct or the field is
        %       missing '*' is assumed.
        function specifyDirs(files_def, identifier, place_holder)
            flds = fieldnames(identifier);
            for ifld = 1:length(flds)
                fld = flds{ifld};
                path_name = [fld '_dir'];
                if ischar(identifier.(fld))
                    if nargin > 2 && isfield(place_holder, fld)
                        phldr = place_holder.(fld);
                    else
                        phldr = '*';
                    end
                    files_def.actl.(path_name) = regexprep(...
                        files_def.smbl.(path_name),...
                        phldr, identifier.(fld), 'once');
                elseif ~identifier.(fld)
                    files_def.actl.(path_name) = '';
                end
            end
        end
        
        % set a path
        % Input:
        %   indentifier - a struct with any of the following fields:
        %       'output', 'case', 'dec'. The field values are the
        %       strings  to set as in the respective
        %       paths.
        function setDirs(files_def, identifier)
            sep = filesep();
            rg = [regexprep(sep, '\', '\\\\') '$'];
            flds = fieldnames(identifier);
            for ifld = 1:length(flds)
                fld = flds{ifld};
                path_name = [fld '_dir'];
                vl = identifier.(fld);
                if isempty(regexp(vl, rg, 'once'))
                    val = [vl sep];
                else
                    val = vl;
                end
                switch path_name
                    case 'input_dir'
                        files_def.input_dir = val;
                    case {'output_dir', 'case_dir', 'dec_dir'}
                        files_def.actl.(path_name) = val;
                end
            end
        end
        
        % Initialize the process of getting files.
        % Input:
        %   files_def - this object
        %   indentifier - (optional) if present first argument to
        %                  specifyDirs()
        %   place_holder: (optional) if present second argument to
        %                  specifyDirs()
        % Output:
        %   indx - the index of the first object to return
        %   err_msg - if present returns error message if directory
        %         creation failed or empty string. If missing an error
        %         causes an exception.
        function [indx, err_msg] = init_getFiles(files_def, identifier,...
                place_holder)
            if nargin >= 2
                if nargin > 2
                    files_def.specifyDirs(identifier, place_holder);
                else
                    files_def.specifyDirs(identifier, place_holder);
                end
            end
            
            err_msg = files_def.makeDirs();
            if ~isempty(err_msg) && nargout < 2
                error('%s', err_msg);
            end
            
            indx = 1;
        end
        
        function istp = isType(files_def, type_name)
            istp = isfield(files_def, type_name);
        end
        
        % Computes and returns a struct defining the I/O files
        % corresponding to a particular base file.
        %
        % Input:
        %   files_def: This object.
        %   indx: Index of base file to use.
        % Output:
        %   fdef: A struct in which the field names are 
        %       are file types, values are file paths with appropriate
        %       extensions.  Note that all files get the path determined by
        %       output_dir/case_dir, except for the fdef.input which gets
        %       the path corresponding to input_dir. If index is beyond the
        %       number of base files, [] is returned.
        %  out_indx: optional. Returns indx incremented by 1
        function [fdef,out_indx] = getFiles(files_def, indx)
            
            if indx > length(files_def.files)
                fdef = [];
                if nargout > 1
                    out_indx = indx;
                end
                return
            end
            
            name = files_def.files{indx};
            fdef = files_def.types;
            flds = fieldnames(fdef);
            paths = cell(size(flds));
            for i=1:length(flds)
                type=flds{i};
                fdef.(type) = [files_def.dirs{files_def.dirs_indx.(type)}...
                    name fdef.(type)];
                prv = find(strcmp(paths(1:i-1), fdef.(type)));
                if prv
                    error('File %s is both %s and %s', fdef.(type), ...
                        flds{prv}, type); 
                end
                paths{i} = fdef.(type);
            end
            if nargout > 1
                out_indx = indx+1;
            end
            
        end % getFiles()
        
        % Get a struct array for all files. Each entry in the array
        % contains the output of getFiles() for a particular index.
        % Input:
        %   files_def - this object
        %   indentifier - (optional) if present first argument to
        %                  specifyDirs()
        %   place_holder: (optional) if present second argument to
        %                  specifyDirs()
        %Outupt
        %   fdef_list - the struct array. If it is a character string it is
        %               an error message.
        %   err_msg - if present returns error message if directory
        %         creation failed or empty string. If missing an error
        %         causes an exception.
        function [fdef_list, err_msg] = getAllFiles(files_def, identifier,...
                place_holder)
            fld_names = fieldnames(files_def.types);
            fdef_list =  cell2struct(...
                cell(length(fld_names), length(files_def.files)),...
                fld_names, 1);
            
            switch nargin
                case 1
                    [indx, err_msg] = files_def.init_getFiles();
                case 2
                    [indx, err_msg] = files_def.init_getFiles(identifier);
                case 3
                    [indx, err_msg] = files_def.init_getFiles(identifier,...
                        place_holder);
            end
            if ~isempty(err_msg)
                if nargout < 2
                    error(err_msg);
                end
                return;
            end
            
            while true
                [fdef, out_indx] = files_def.getFiles(indx);
                if out_indx == indx
                    break;
                end
                fdef_list(indx) = fdef;
                indx = out_indx;
            end
        end
        
        function dir_name = getEncoderDir(files_def)
            dir_name = [files_def.actl.output_dir files_def.actl.case_dir];
        end
        
        function dir_name = getDecoderDir(files_def)
            dir_name = [files_def.actl.output_dir files_def.actl.dec_dir...
                files_def.actl.case_dir];
        end
        
        function dir_name = outputDir(files_def)
            dir_name = [files_def.actl.output_dir files_def.actl.dec_dir];
        end
        
        function err_msg = makeOutputDir(files_def)
            err_msg = files_def.makeDir(files_def.outputDir(), 'output');
            if ~isempty(err_msg) && nargout == 0;
                error('%s',err_msg);
            end
        end
        
        function dir_name = caseDir(files_def)
            dir_name = files_def.actl.case_dir;
        end
        
        function case_dirs = getCaseDirs(files_def)
            case_dirs = dir([files_def.actl.output_dir files_def.case_dir_pattern]);
            drs = cell(size(case_dirs));
            j=0;
            for k=1:length(case_dirs);
                if ~case_dirs(k).isdir || strcmp(case_dirs(k).name,'.') || ...
                        strcmp(case_dirs(k).name,'..')
                    continue;
                end
                j=j+1;
                drs{j} = case_dirs(k).name;
            end
            case_dirs = drs(1:j);
        end
        
        % makeDirs fills dirs with appropriate values. identifier and
        % place_holder are specified, specifyDirs is called before hand.
        % Input:
        %   files_def - this object
        % Output: reports success. 
        %   err_msg - An error message. Empty if successful. 
        function err_msg = makeDirs(files_def)
            files_def.dirs = {files_def.input_dir, ...
                files_def.getEncoderDir(), files_def.getDecoderDir()};
            
            err_msg = files_def.makeDir(files_def.dirs{2}, 'encoder');
            if ~isempty(err_msg)
                if nargout == 0
                    error('failed making encoder dir %s\n  %s', ...
                        files_def.dirs{2}, err_msg);
                end
                return;
            end
            err_msg = files_def.makeDir(files_def.dirs{3}, 'decoder');
            if ~isempty(err_msg)
                if nargout == 0
                    error('failed making decoder dir %s\n  %s', ...
                        files_def.dirs{3}, err_msg);
                end
                return;
            end
        end
        
    end   % Methods
    
    methods (Access=private)

    end   % Access = private
    
    methods (Access=private, Static=true)
        function [fields, exts, dir_types] = chkTypes(types, fields)
            std_type_names = struct2cell(FilesDef.std_types);
            std_type_names = std_type_names(1,:);
            typenames = cell(length(types),1);
            exts = typenames;
            dir_types = typenames;
            ntypes = 0;
            
            for itp=1:length(types)
                tps = types{itp};
                if isstruct(tps)
                    ityp=fieldnames(tps);
                    if length(ityp) > 1
                        % Ignore types with more than one entry
                        continue;
                    end
                    ityp=ityp{1}; % type name
                    iext = tps.(ityp);
                else
                    ityp = tps;
                    iext = [];
                end
                
                if ityp(1) == '~'  
                    continue;
                end
                if nargin >= 2 && ~ismember(ityp,fields)
                    continue;
                end
                indx = find(strcmp(std_type_names, ityp), 1);
                
                if isempty(indx)
                    error('Unrecognized type: %s', ityp);
                elseif ismember(ityp, typenames(1:ntypes))
                    error('Repeated type: %s', ityp);
                elseif isempty(iext)
                    % use default
                    iext = FilesDef.std_types(indx).ext;
                end
                
                ntypes = ntypes + 1;
                typenames{ntypes} = ityp;
                exts{ntypes} = iext;
                dir_types{ntypes} = FilesDef.std_types(indx).place;
            end
            
            typenames = typenames(1:ntypes);
            exts = exts(1:ntypes);
            dir_types = dir_types(1:ntypes);
            if nargin >= 2
                mm = ismember(fields, typenames);
                if ~all(mm)
                    indx = find(~mm,1);
                    error('Field "%s" is missing in types spec', fields(indx));
                end
            else
                fields = typenames;
            end
            
        end
        
        function dir_name = getDirNames(info, field)
            if isfield(info,field);
                dir_name = info.(field);
                if ~strcmp(dir_name(end), '/')
                    dir_name = [dir_name '/'];
                end
                
                % Change path separator to be platform specific
                sep=filesep();
                if ~strcmp(sep,'/')
                    dir_name = regexprep(dir_name, '[/]', sep);
                end
            else
                dir_name = '';
            end
        end  % getDirNames
        
        function err_msg = makeDir(dir_path, dir_name)
            [status, emsg] = mkdir(dir_path);
            if ~status
                err_msg = sprintf('Failed creating %s directory (%s):\n\t%s', ...
                    dir_name, dir_path, emsg);
            else
                err_msg = '';
            end
        end
            
    end % private static methods
    
    
end

