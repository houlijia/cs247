classdef VidBlocker <  matlab.mixin.Copyable
    %VidBlocker objects contains operator to divide video into equal size blocks
    %and to reconstruct it back from those blocks.
    %   Detailed explanation goes here
    properties (Constant)
      % If true, interpolation constraints are generated by getCnstrnt().
      chk_expand_matrix = false;
      
      vid_info_flds = {'vid_size_v', 'vid_size_h', 'vid_size_t', ...
        'uv_ratio_v', 'uv_ratio_h', 'uv_ratio_t', 'fps';...
        'I','I','I','I','I','I','F'};
      
      blk_info_flds = {'indx_v', 'indx_h', 'indx_t',...
        'ofst_v', 'ofst_h', 'ofst_t',...
        'len_v', 'len_h', 'len_t',...
        'ovlp_b_v', 'ovlp_b_h', 'ovlp_b_t',...
        'ovlp_f_v', 'ovlp_f_h', 'ovlp_f_t',...
        'yw_type';...
        'I','I','I', ...
        'I','I','I', ...
        'I','I','I', ...
        'I','I','I', ...
        'I','I','I',...
        'I'...
        };
      
      % Processing state of a video block. These are sequential steps in 
      % the processing of a block
      BLK_STT_RAW = 1; % Raw block - no processing
      BLK_STT_INTRPLT = 2; % UV components have been interpolated to size of Y
      BLK_STT_EXTND = 3; % edge blocks have been extended to full size
      BLK_STT_WNDW = 4; % Block has been windowed.
    end
    
    properties
        % The ratio between the size in the Y component and the sizes in
        % the UV componensts. Empty if luminance only
        uv_ratio = [];
        
        % An array of n_clr by 3 of the sizes of the raw video in each
        % component.
        vid_size = [];
        
        % Frames per second
        fps;
        
        % Block size. each row is (height, width, time) of one component.
        % If the block is black and white there is one row (Y), otherwise
        % there are 3 rows (YUV). blk_size(k,:) for k>1 must be divisible 
        % by uv_ratio
        blk_size=[];
        
        % Block overlap. Each row is the overlap (height, width, time) of
        % one component. Number of rows is same as blk_size. ovrlp(k,:)
        % for k>1 must be divisible by uv_ratio
        ovrlp=[];
        
        wnd_enc_type=[];     % type of window for encoding
        wnd_dec_type=CS_DecParams.WND_TRIANGLE;     % type of window for decoding
        
    end
    
    properties (Access = private)
        wnd_enc=[];         % window for encoding
        wnd_dec=[];         % window for decoding
       
        % a 3D matrix of the windowing weights in each pixel of a block       
        wnd_enc_blk_wgts = [];   
    end
    
    methods
        % Constructor
        % Input (all parameters are optional)
        %   yb_size - values for Yblk_size (V,H,T)
        %   params - a struct of parameters which may contain the
        %   following fields:
        %     w_blk - value of wnd_blk.
        %     w_type_e - value of encoder wnd_type
        %     w_type_d - value of decoder wnd_type
        %     ovrlp  - overlap of the Y block (default = [0 0 0]);
        %     vid_size - video size spec: Either a cell
        %               array of 1 or 3 entires (Y or YUV), each containing
        %               a three dimensional array of the pixels, or the 
        %               sizes of the raw video as an array of n_colors by
        %               3.
        %     fps    - frames per second
        %     monochrom - (optional) if pressent and true, force monochromatic
        %               processing
        %     linient - normally if yb_size is divisible by
        %               UVrat, an error occurs.  If linient is true we
        %               divide and truncate (default = false)
        %   params can also be n existing VidBlocker object, in which case
        %   the parameters will be copied from it.
        function obj = VidBlocker(yb_size, params)
            if nargin > 0
                if nargin <= 1
                    params = struct();
                end
                if isa(params, 'VidBlocker')
                    params = params.getParams();
                else
                    if ~isfield(params, 'w_type_e')
                        params.w_type_e = obj.wnd_enc_type;
                    end
                    if ~isfield(params, 'w_type_d')
                        params.w_type_d = obj.wnd_dec_type;
                    end
                    if ~isfield(params, 'ovrlp')
                        params.ovrlp = [0 0 0];
                    end
                    if ~isfield(params, 'fps')
                        params.fps = 30; % Default value
                    end
                end
                obj.init(yb_size, params);
            end
        end
       
        function eql = isEqual(obj, other)
            if class(obj) ~= class(other)
%                 warning('isEqual:class','isEqual class different: %s ~= %s', ...
%                     class(obj), class(other));
                eql = false;
                return;
            end
            
            otr = other.copy();
            otr.wnd_enc_blk_wgts = obj.wnd_enc_blk_wgts;
            
            props = sort(properties(obj));
            for k=1:length(props)
                prop = props{k};
                if isobject(obj.(prop)) && ismethod(obj.(prop),'isEqual')
                    if ~ obj.(prop).isEqual(otr.(prop))
%                         warning('isEqual:isEqual','isEqual(%s.%s) failed',...
%                             class(obj), prop);
                        eql = false;
                        return;
                    end
                else
                    if ~isequal(obj.(prop), otr.(prop))
%                         warning('isEqual:same','isEqual(%s.%s) failed',...
%                             class(obj), prop);
                        eql = false;
                        return
                    end
                end
            end
            
            eql = true;
        end
        
        % Calculate the number of blocks in a video.
        function blk_cnt = calcBlkCnt(obj)
            bsize = obj.blk_size(1,:);
            olp = obj.ovrlp(1,:);
            blk_cnt = ceil((obj.vid_size(1,:)+olp)./(bsize-olp));
        end
        
        % Calculate the number of blocks in a video, counting each color
        % component separately.
        %   Ysize can be the size of the Y component of the raw video
        %   or a cell array containing the video itself
        %   blk_cnt is an array of [C,V,H,T], where C is a color component
        %   number
        function blk_cnt = calcClrBlkCnt(obj)
            blk_cnt = [size(obj.blk_size,1) obj.calcBlkCnt()];
        end
        
        % Get the number of pixels in a clr block (including extension)
        function n_pxl = ttlPxlClrBlk(obj)
            n_pxl = prod(obj.blk_size(1,:));
        end
        
        % Return information about the video as a whole in the form of a
        % struct.
        function vid_info = getVidInfo(obj)
            if isempty(obj.uv_ratio)
                uvr = [0, 0, 0];
            else
                uvr = obj.uv_ratio;
            end
            
            vid_info = struct(...
                'vid_size_v', obj.vid_size(1,1),...
                'vid_size_h', obj.vid_size(1,2),...
                'vid_size_t', obj.vid_size(1,3),...
                'uv_ratio_v', uvr(1),...
                'uv_ratio_h', uvr(2),...
                'uv_ratio_t', uvr(3),...
                'fps', obj.fps);
        end
        
        % Return information about single block in the form of a struct
        % Input
        %   obj - this object
        %   v - vertical block index
        %   h - horizontal block index
        %   t - temporal block index
        % Output
        %   blk_info -a struct with fields specified by blk_info_flds
        function blk_info = getBlkInfo(obj,v,h,t)
            if nargin == 2
                indx = v;
            else
                indx = [v,h,t];
            end
            [offset, ~, len, ~, ~, blk_ofst] = obj.blkPosition(indx);
            blk_info = cell(1,size(obj.blk_info_flds,2));
            blk_info = cell2struct(blk_info,obj.blk_info_flds(1,:),2);
            dm = {'_v','_h','_t'};
            for k=1:3
                blk_info.(['indx' dm{k}]) = indx(k);
                blk_info.(['ofst' dm{k}]) = offset(1,k)-1;
                blk_info.(['len' dm{k}]) = len(1,k);
                blk_info.(['ovlp_b' dm{k}]) = obj.ovrlp(1,k) - blk_ofst(1,k);
                blk_info.(['ovlp_f' dm{k}]) = obj.ovrlp(1,k) + ...
                    obj.blk_size(1,k) - blk_ofst(1,k) - len(1,k);
            end
            blk_info.w_type_e = obj.wnd_enc_type;
            blk_info.w_type_d = obj.wnd_dec_type;
        end
    
        % Get a block with a uniform content
        %  Input
        %    obj - this object
        %    val - value to assign to all pixels (devault = 0)
        %  Output
        %    blk - Array of size blk_size(1,:)
        function blk = getUniformBlk(obj, val)
            if nargin < 2
                blk  = zeros(obj.blk_size(1,:));
            else
                blk  = ones(obj.blk_size(1,:)) * val;
            end
        end
        
        % Extract one block from the video raw_vid. 
        % blk_indx is the index of the block in raw_vid.
        %   Input:
        %     obj - this object
        %     raw_vid - raw video. A cell array of 1 (Y) or 3 (YUV) cells.
        %     blk_indx - index of block in video
        %  Output:
        %     blk - Output blk. A cell array of 1 (Y) or 3 (YUV) cells.
        %           first and last blocks are extended with same values.
        %           UV components are interpolated to the same size as Y.
        function blk = getSingleBlk(obj, raw_vid, blk_indx)
            [orig, blk_end, ~, ~, ~, blk_ofst] = obj.blkPosition(blk_indx);
            
            blk = obj.do_getSingleBlk(raw_vid, blk_indx, ...
                orig, blk_end, blk_ofst);
        end
        
        % Put a single block into raw_vid.
        function raw_vid = putSingleBlk(obj, blk, raw_vid, blk_indx, blk_stt)
          % Skip empty blocks
          if isempty(blk) || isempty(blk{1})
            return
          end
          
          [orig, blk_end, blen, is_first, is_last, blk_ofst] =...
            obj.blkPosition(blk_indx);
          
          % If the block has been windowed but not with the right window,
          % or if it is a first or last block, which is windowed on
          % encoding but not on decoding, the windowing has to be undone
          if blk_stt == obj.BLK_STT_WNDW && ...
              (~isequal(obj.wnd_enc_type, obj.wnd_dec_type) ||...
              any((is_first|is_last) & obj.ovrlp(1,:)))
            blk = obj.unWindowBlk(blk, obj.wnd_enc, [0,0,0], [0,0,0]);
            blk_stt = obj.BLK_STT_EXTND;
          end
          
          % If windowing is needed and the block is not in BLK_STT_EXTND,
          % it needs to be brought to this state
          if blk_stt < obj.BLK_STT_WNDW && any(obj.ovrlp(:))
            if blk_stt == obj.BLK_STT_RAW
              blk = obj.interpolate(blk);
              blk_stt = obj.BLK_STT_INTRPLT;
            end
            if blk_stt == obj.BLK_STT_INTRPLT;
              blk = obj.extendBlk(blk);
              blk_stt = obj.BLK_STT_EXTND;
            end
            if blk_stt == obj.BLK_STT_EXTND
              blk = obj.windowBlk(blk, obj.wnd_dec, is_first, is_last);
            end
          elseif blk_stt == obj.BLK_STT_WNDW
            blk_stt = obj.BLK_STT_EXTND;
          end
            
          if obj.chk_expand_matrix && blk_stt == obj.BLK_STT_EXTND
            r_mtrx = obj.getUnExpandMtrx(blk_indx,2);
            ref_blk = cell(1,3);
            for k=1:size(obj.blk_size,1)
              ref_blk{k} = r_mtrx{k}.multVec(blk{k}(:));
            end

          else
            ref_blk = [];
          end
          
          if blk_stt == obj.BLK_STT_EXTND
            blk = obj.undoExtendBlk(blk, blk_ofst(1,:), blen(1,:));
            blk_stt = obj.BLK_STT_INTRPLT;
          end
          if  blk_stt == obj.BLK_STT_INTRPLT
            blk = obj.undoInterpolate(blk);
          end
          
          for k=1:size(obj.blk_size,1)
            blk_val = blk{k};
            if ~isempty(ref_blk)
              ref_blk = reshape(ref_blk, blen(k,:));
              df = blk_val - ref_blk;
              if max(abs(df(:))) > 1e-12
                warning('getSingleBlk:UnExpand',...
                  'ref_blk{%d} ~= blk_val. max err=%f',k,max(abs(df(:))))
              end
            end
            
            raw_vid{k}(orig(k,1):blk_end(k,1), orig(k,2):blk_end(k,2),...
              orig(k,3):blk_end(k,3)) =...
              raw_vid{k}(orig(k,1):blk_end(k,1), orig(k,2):blk_end(k,2),...
              orig(k,3):blk_end(k,3)) + blk_val;
          end
          
        end

        
        % Extract one or more blocks from the video raw_vid. 
        % blk_indx (optional, default=[]) can be empty of have 1,2,or,3 entries.
        % If it has 3 entries, one block is read, whose index is blk_indx.
        % If it has 2 entries a column of blocks is read whos H,T indices
        % are blk_indx.  If it has 1 entry, a matrix of blocks is read whos
        % T index is blk_indx. If blk_indx is empty all the blocks in
        % raw_vid are extracted.
        % Output:
        %    blk - a cell array of (C,V,H,T) (component, vertical, 
        %          horizontal, time) where each cell contains
        %          a three dimensional array of pixels.
        %    nxt_blk_indx is of the same dimension as blk_indx and is the
        %         position of the next block or group of blocks.
        function [blk, nxt_blk_indx] = getBlk(obj, raw_vid, blk_indx)
            if nargin < 3
                blk_indx = [];
            end
            
            blk_cnt = obj.calcBlkCnt();
            n_clr = size(obj.blk_size, 1);
            len_blk_indx = length(blk_indx);
            if len_blk_indx < 3
                blk = cell([n_clr blk_cnt(1:end-len_blk_indx)]);
                switch len_blk_indx
                    case 0
                        for k=1:blk_cnt(3)
                            blk0 = obj.getBlk(raw_vid, [k blk_indx]);
                            if isempty(blk0)
                                blk = [];
                                break;
                            end
                            blk(:,:,:,k) = blk0;
                        end
                    case 1
                        for k=1:blk_cnt(2)
                            blk0 = obj.getBlk(raw_vid, [k blk_indx]);
                            if isempty(blk0)
                                blk = [];
                                break;
                            end
                            blk(:,:,k) = blk0;
                        end
                    case 2
                        for k=1:blk_cnt(1)
                            blk0 = obj.getBlk(raw_vid, [k blk_indx]);
                            if isempty(blk0)
                                blk = [];
                                break;
                            end
                            blk(:,k) = blk0;
                        end
                end
            else
                blk = obj.getSingleBlk(raw_vid, blk_indx);
                if isempty(blk)
                    blk = [];
                end
            end
            
            if isempty(blk)
                nxt_blk_indx = [];
            else
                nxt_blk_indx = obj.calcNxtIndx(blk_indx);
            end
        end
        
        % Put one or more blocks blks into the raw video array raw_vid.
        % blks is the array of blocks to insert. It can be a single block, 
        % a column of blocks,a matrix of blocks (V,H) or a 3 dimnsional array
        % of blocks. raw_vid (optional) is the raw video into which the blocks
        %  need to be put. If not given it will be created.
        % blk_indx (optional) is the position in which the block needs to
        % be put. It can be missing only if raw_vid is missing.  Otherwise,
        % if it has 3 entries, blks has to have a single entry indicated by
        % blk_indx.  If it has 2 entries, blks has to be a column of blocks
        % whose position is givenby blk_indx.  If it has 1 entry the blks
        % should be a matrix of blocks (V,H) with temporal position
        % indicated by blk_indx. If blk_indx is empty then blks should be
        % three dimensional and fill raw_vid
        % 
        % The function returns the updated raw vid
        % nxt_blk_indx is of the same dimension as blk_indx and is the
        % position of the next block or group of blocks.
        function [raw_vid, nxt_blk_indx] = putBlk(obj, blks, blk_stt, raw_vid,...
                blk_indx)
            n_clr = size(obj.blk_size, 1);
            
            if nargin < 5
                if nargin == 4
                    error('blk_indx cannot be missing when raw_vid is specified');
                else
                    raw_vid = cell(n_clr,1);
                    for k = 1:n_clr
                        raw_vid{1} = zeros(size(blks(2:end)) .* ...
                            (obj.blk_size(k,:)-obj.ovrlp(k,:)) + obj.ovrlp(k,:));
                    end
                    blk_indx = [];
                end
            end
            
            len_blk_indx = length(blk_indx);
                
            if len_blk_indx < 3
                switch len_blk_indx
                    case 0
                        for k=1:size(blks,4)
                            raw_vid = obj.putBlk(blks(:,:,:,k), blk_stt,...
                                raw_vid, [k blk_indx]);
                        end
                    case 1
                        for k=1:size(blks,3)
                            raw_vid = obj.putBlk(blks(:,:,k), blk_stt,...
                                raw_vid, [k blk_indx]);
                        end
                    case 2
                        for k=1:size(blks,2)
                            raw_vid = obj.putBlk(blks(:,k), blk_stt,...
                              raw_vid, [k blk_indx]);
                        end
                end
            else
                raw_vid = obj.putSingleBlk(blks, raw_vid, blk_indx, blk_stt);
            end
            
            nxt_blk_indx = obj.calcNxtIndx(blk_indx);            
        end
        
        % Write arrays of blocks into a file
        % Input
        %   obj - this object
        %   outfile - a file name (string) or a file handle. If  empty, or
        %             numeric and equals -1, no writing is done.
        %   blks - an array of 4 dimensions - color, height, width, time
        %          (frame).  Missing upper indices are taken
        %          as 1.
        %   rvid - RawVidInfo object specifying the structure of the output
        %          file
         %  blk_stt - processing state of the blocks (BLK_STT_...)
        %   frm_ovrlp - (optional) If not empty it is a cell array of residual
        %            video corresponding to temporal overlay. One cell for 
        %            each color, where the number of frames in each color
        %            is obj.ovrlp(iclr,3).
        %   is_diff (optional) - if true, data is a difference and will be
        %          scaled and centered. Default, false.
        % Output
        %   nfr - If successful, number of frames written out.  otherwise
        %         an error message
        %   vid - returns the output videos.  If outfiles is a cell array
        %         it is a cell array of videos.  Otherwise it is a single
        %         video, where a video is a cell array of 1 (black and
        %         white) or 3 (YUV) arrays.
        %   frm_ovrlp - Residual video for next writing. Contains cells with
        %               3-dimensional blocks where the
        %               third dimension is obj.ovrlp(1,3). If missing all
        %               cells will be written
        function [nfr, vid, frm_ovrlp] = writeBlocks(obj, outfile, blks, rvid, ...
                blk_stt, frm_ovrlp, is_diff)

            if nargin < 7
                is_diff = false;
                if nargin < 6
                    frm_ovrlp = [];
                end
            end
            inp_ovrlp = frm_ovrlp;            
            if obj.ovrlp(1,3)==0 || isempty(inp_ovrlp)
                nfr = size(blks,4)*(obj.blk_size(1,3) - obj.ovrlp(1,3));
                vid = rvid.createEmptyVideo(nfr);
                vid = obj.putBlk(blks(:,:,:,:), blk_stt, vid, []);
            else
                nfr = (size(blks,4)+1)*(obj.blk_size(1,3) - obj.ovrlp(1,3));
                vid = rvid.createEmptyVideo(nfr);
                % Add overlap frames
                for iclr = 1:min(length(inp_ovrlp),size(blks,1))
                    frm_stp = obj.blk_size(iclr,3)- obj.ovrlp(iclr,3);
                    vid{iclr}(:,:,frm_stp-obj.ovrlp(iclr,3)+1: frm_stp) =...
                        inp_ovrlp{iclr};
                end
                
                %insert blocks
                for k=1:size(blks,4)
                    % Use of k+1 indicates to putBlk that this is not 
                    % temporally first, hence it should not be truncated.
                    vid = obj.putBlk(blks(:,:,:,k), blk_stt, vid, k+1);
                end
                
                % Remove filler frames
                for iclr=1:length(vid)
                    bgn = obj.blk_size(iclr,3)- 2*obj.ovrlp(iclr,3) + 1;
                    vid{iclr} = vid{iclr}(:,:,bgn:end);
                end
                nfr = nfr - (obj.blk_size(1,3)-2*obj.ovrlp(1,3));
            end
            
            % Generate output overlap
            if obj.ovrlp(1,3)
                if nargout >= 3
                    frm_ovrlp = rvid.createEmptyVideo(obj.ovrlp(1,3));
                    for iclr = 1:length(vid)
                        frm_ovrlp{iclr} = vid{iclr}(:,:,end-obj.ovrlp(iclr,3)+1:end);
                    end
                end
                
                % Remove end overlap from vid
                for iclr=1:length(vid)
                    vid{iclr} = vid{iclr}(:,:,1:end-obj.ovrlp(iclr,3));
                end
                nfr = nfr - obj.ovrlp(1,3);
            else
                frm_ovrlp = [];
            end
            
            if is_diff
                for iclr = 1:size(blks,1)
                    vid{iclr} = 0.5*(vid{iclr}+rvid.getPixelMax());
                end
            end
            
            % check if writing out is necessary
            if ~(isempty(outfile) || (isnumeric(outfile) && outfile==-1))
                
                % Convert to integer and write out
                vid_int = vid;
                for iclr = 1:size(blks,1)
                    vid_int{iclr} = rvid.convertValsToPxls(vid_int{iclr});
                end
                err_msg = write_raw_video(outfile, vid_int);
                if ~isempty(err_msg)
                    nfr = err_msg;
                end
            end
        end
        
        % Provides information about a block position in the raw video
        % volume.
        % input:
        %   obj - this object
        %   blk_indx - index of block (V,H,T)
        % output:
        %   origin - lowest coordingates of block in raw video
        %   blk_end - highest coordinates of block in raw video
        %   blk_len - size of the subblock  containing original pixels - the
        %             nominal block size minus overlap outside the raw video.
        %   is_first - a row vector with logical values indication whether
        %             this is a first block in each dimension
        %   is_last  - a row vector with logical values indication whether
        %             this is a last block in each dimensin
        %   blk_ofst - Start of original video pixels in the block. In 
        %             dimensions where the block is first this is the
        %             overlap.  Otherwise it is zero.
        %   
        function [origin, blk_end, blk_len, is_first, is_last, blk_ofst] =...
                blkPosition(obj, blk_indx)
            is_first = (blk_indx == 1);
            n_clr = size(obj.blk_size,1);
            
            vsize = obj.vid_size; 
            blk_cnt = obj.calcBlkCnt();
            is_last = (blk_indx == blk_cnt);
            b_sz = obj.blk_size - obj.ovrlp;
            clr_ones = ones(n_clr,1);
            % If blocks do not fit evenly in vertical or horizontal
            % dimensions, arrange blocks so that the slack on both sides is
            % the same.
            slack = (clr_ones * blk_cnt) .* b_sz + obj.ovrlp - ...
                (obj.vid_size + 2*obj.ovrlp);
            slack(:,3) = 0; % Not applies to temporal
            slack = obj.ovrlp + floor(slack/2);
            blk_ofst = (clr_ones * is_first) .* slack;
            start = (clr_ones * (blk_indx-1)) .* b_sz + 1; % in raw video
            origin = start - slack + blk_ofst;  % correct for overlap
            blk_len = min(obj.blk_size-blk_ofst, vsize-(origin-1));
            blk_end = origin + blk_len -1;
        end
        
        % Compute the number of pixels in a block (not including zero
        % extension, but including all colors). overlap pixels count is
        % divided by the number of blocks with which they are shared.
        % input:
        %   obj - this object
        %   blk_indx - index of block (V,H,T)
        % Output
        %   n_pxl - number of pixels in the block
        function n_pxl = nPxlInBlk(obj, blk_indx)
            [~,~,blk_len, is_first, is_last,~] = obj.blkPosition(blk_indx);
            
            blk_len = blk_len - ...
                (ones(size(obj.ovrlp,1),1)*(0.5*(2-(is_first+is_last)))).*...
                obj.ovrlp;
            n_pxl = sum(prod(blk_len,2));
        end
                
        % Get the pre-encode windowing weights for one color block.
        %   Input:
        %   blk_indx - index of block (V,H,T)
        function wgts = getWindowCBlkWgts(obj)
          if isempty(obj.wnd_enc_blk_wgts)
            sz = obj.blk_size(1,:);
            lsz = prod(sz);
            indcs = (1:lsz)';
            wgts = reshape(ones(size(indcs)), sz);
            obj.wnd_enc_blk_wgts = obj.windowBlk(wgts, obj.wnd_enc, [0,0,0], [0,0,0]);
          end
          wgts = obj.wnd_enc_blk_wgts;
        end
        
        % Compute matrices which un-expand expanded video, given as a
        % vector of pixesls.  The output is a cell array of matrices, one
        % for each component.
        % Input:
        %   obj - this object
        %   blk_index - [h v t] block address
        %   level - level of expansion:
        %     0 - no un-expansion
        %     1 - output matrices only remove block extension outside the
        %         video boundaries.
        %     2 - output matrices both remove block extension outside the
        %         video boundaries and decimate color components.
        % Output
        %   mtrcs - A cell vector of size [1, n_clr] (where n_clr is the
        %           number of components).  Each cell contains the
        %           expansion matrix for this component.
        %   i_mtrcs - A cell array like mtrcs, but the matrices in each
        %           cell perform only decimation, not block extension removal.
        %
        %  The operation depends on the value of level. If level = 0 mtrcs
        %  and i_mtrcs will contain empty arrays.  If level>1 the
        %  corresponding matrices in mtrcs and i_mtrcs will have the same
        %  number of rows (same output) but the number of columns in the
        %  matrices of mtrcs may be higher, because i_mtrcs operate on 
        %  vectors in which extensions have already been removed. If level=1,
        %  i_mtrcs contain unit matrices, since no interpolation is done.
        
        function [mtrcs, i_mtrcs] = getUnExpandMtrx(obj, blk_indx, level)
            n_clr = size(obj.blk_size,1);
            mtrcs = cell(1,n_clr);
            i_mtrcs = cell(1,n_clr);
            if level == 0
                return
            end
            
            i_mtrx = []; % un-interpolation
            e_mtrx = obj.getUnExtendMtrx(blk_indx);
            ie_mtrx = [];
            for i_clr = 1:n_clr
                if i_clr == 1 || level == 1
                    mtrcs{i_clr} = e_mtrx;
                    i_mtrcs{i_clr} = SensingMatrixUnit(e_mtrx.nCols());
                else
                    if isempty(i_mtrx)
                        i_mtrx = obj.getUnInterpolateMtrx(blk_indx);
                        ie_mtrx = SensingMatrixMatlab(i_mtrx.getMatrix()*...
                            e_mtrx.getMatrix());
                    end
                    mtrcs{i_clr} = ie_mtrx;
                    i_mtrcs{i_clr} = i_mtrx;
                end
            end
        end

        % Compute matrices which expand original video when given as a
        % vector of pixels.  The output is a cell array of matrices, one
        % for each component.
        % Input:
        %   obj - this object
        %   blk_index - [h v t] block address
        %   level - level of expansion:
        %     0 - no expansion
        %     1 - output matrices only extend block if it is first or last
        %         in some dimensions and there is an overlap outside the
        %         video boundaries (assume color components have already been
        %         interpolated).
        %     2 - output matrices both interpolate color components and
        %         expand first or last blocks when there is overlap outside
        %         the boundary.
        % Output
        %   mtrcs - A cell vector of size [1, n_clr] (where n_clr is the
        %           number of components).  Each cell contains the
        %           expansion matrix for this component.
        %   i_mtrcs - A cell array like mtrcs, but the matrices in each
        %           cell perform only interpolation, not expansion.
        %
        %  The operation depends on the value of level. If level = 0 mtrcs
        %  and i_mtrcs will contain empty arrays.  If level>1 the
        %  corresponding matrices in mtrcs and i_mtrcs will have the same
        %  number of columns (same input) but the number of rows in the
        %  matrices of mtrcs may be higher. If level=1, the output matrices
        %  are supposed to act on a pixel vector in which color components
        %  have already been interpolated (hence i_mtrcs will be unit
        %  matrices).  If level=2 color components may be have less pixels
        %  hence i_mtrcs for color componsnts may be (linear) interpolation
        %  matrices.
        
        function [mtrcs, i_mtrcs] = getExpandMtrx(obj, blk_indx, level)
            n_clr = size(obj.blk_size,1);
            mtrcs = cell(1,n_clr);
            i_mtrcs = cell(1,n_clr);
            if level == 0
                return
            end
            
            e_mtrx = obj.getExtendMtrx(blk_indx);
            i_mtrx = []; % interpolation
            ei_mtrx = [];
            for i_clr = 1:n_clr
                if i_clr == 1 || level == 1
                    mtrcs{i_clr} = e_mtrx;
                    i_mtrcs{i_clr} = SensingMatrixUnit(e_mtrx.nCols());
                else
                    if isempty(i_mtrx)
                        i_mtrx = obj.getInterpolateMtrx(blk_indx);
                        ei_mtrx = SensingMatrixMatlab(e_mtrx.getMatrix()*...
                            i_mtrx.getMatrix());
                    end
                    mtrcs{i_clr} = ei_mtrx;
                    i_mtrcs{i_clr} = i_mtrx;
                end
            end
        end  
        
        function params = getParams(obj)
          vsize = obj.vid_size;
          params = struct(...
            'w_type_e', obj.wnd_enc_type,...
            'w_type_d', obj.wnd_dec_type,...
            'ovrlp', obj.ovrlp(1,:),...
            'vid_size', vsize,...
            'monochrom', isempty(obj.uv_ratio),...
            'fps', obj.fps);
        end
        
end
    
    methods (Static)
        function flds = getBlkInfoFields()
            flds = VidBlocker.blk_info_flds;
        end
        
        function flds = getVidInfoFields()
            flds = VidBlocker.vid_info_flds;
        end
    end
    
    methods (Access = protected)
        
        function blk = do_getSingleBlk(obj, raw_vid, blk_indx, ...
                orig, blk_end, blk_ofst)
            
            if obj.chk_expand_matrix
                e_mtrx = obj.getExpandMtrx(blk_indx, 2);
            end
            
            blk = cell(size(obj.blk_size,1),1);
            
            for k=1:size(obj.blk_size,1)
                blk_val = double(...
                    raw_vid{k}(orig(k,1):blk_end(k,1), orig(k,2):blk_end(k,2),...
                    orig(k,3):blk_end(k,3)));
                if isempty(blk_val)
                    blk = [];
                    return
                end
                
                if obj.chk_expand_matrix
                    ref_blk = e_mtrx{k}.multVec(blk_val(:));
                    ref_blk = reshape(ref_blk, obj.blk_size(1,:));
                end
                
                % Interpolate
                if k>1
                    blk_val = obj.interpolate(blk_val);
                end
                
                % Extend
                blk_val = obj.extendBlk(blk_val, blk_ofst(1,:));
                
                if obj.chk_expand_matrix
                    df = blk_val - ref_blk;
                    if max(abs(df(:))) > 1e-12
                        warning('getSingleBlk:Expand',...
                            'ref_blk{%d} ~= blk_val. max err=%f',...
                            k,max(abs(df(:))))
                    end
                end
                
                %Window if necessary (window even first and last blocks)
                blk_val = obj.windowBlk(blk_val, obj.wnd_enc, ...
                  [0,0,0], [0,0,0]);
                
                % put in place
                blk{k} = blk_val;
            end
        end
    end
    
    methods (Access=private)
        
        function init(obj, yb_size, params)
            obj.wnd_enc_type = params.w_type_e;
            obj.wnd_dec_type = params.w_type_d;
            
            
            obj.fps = params.fps;
            
            % Compute size of raw video in each color
            if iscell(params.vid_size)
                n_clr = length(params.vid_size);
                if isfield(params, 'monochrom') && params.monochrom
                    n_clr = 1;
                end
                vsize = ones(n_clr,3);
                for k=1:n_clr
                    sz = size(params.vid_size{k});
                    vsize(k,1:length(sz)) = sz;
                end
            else
                n_clr = size(params.vid_size,1);
                if isfield(params, 'monochrom') && params.monochrom
                    n_clr = 1;
                end
                vsize = ones(n_clr,3);
                vsize(1:n_clr,:) = params.vid_size(1:n_clr,:);
            end
            obj.vid_size = vsize;
            
            if size(vsize,1) > 1
                obj.uv_ratio = vsize(1,:) ./ vsize(2,:);
                if (~isfield(params, 'linient') || ~params.linient) &&...
                        any(any(mod([yb_size; params.ovrlp], ...
                         ones(size([yb_size;params.ovrlp],1),1)*obj.uv_ratio)));
                    error('yb_size and ovrlp must be divisible by uv_ratio');
                end
                uv_size =  floor(yb_size ./ obj.uv_ratio);
                uv_ovrlp =  floor(params.ovrlp ./ obj.uv_ratio);
                obj.blk_size = [yb_size; uv_size; uv_size];
                obj.ovrlp = [params.ovrlp; uv_ovrlp; uv_ovrlp];
            else
                obj.uv_ratio = [];
                obj.blk_size = yb_size;
                obj.ovrlp = params.ovrlp;
            end
            
            % compute window
            if ~isempty(obj.wnd_enc_type)
              obj.wnd_enc = struct('b',[],'f',[]); % for (V,H,W)
              obj.wnd_enc.b = initWindow(obj.wnd_enc_type);
              for k=1:3
                obj.wnd_enc.f{k} = obj.wnd_enc.b{k}(end:-1:1);
              end
            end
            if ~isempty(obj.wnd_dec_type)
              obj.wnd_dec = struct('b',[],'f',[]); % for (V,H,W)
              obj.wnd_dec.b = initWindow(obj.wnd_dec_type);
              for k=1:3
                obj.wnd_dec.f{k} = 1 - obj.wnd_dec.b{k};
              end
            end
            
          function wnd = initWindow(type)
            wnd = cell(1,3);
            for d=1:length(wnd)
              N = params.ovrlp(d);
              if ~N
                wnd{d} = [];
                continue;
              end
              
              switch type
                case CS_EncParams.WND_NONE;
                  wnd{d} = [];
                case CS_EncParams.WND_HANNING
                  wnd{d} = 0.5 + 0.5*cos((pi/(N+1))*(N:-1:1)');
                case CS_EncParams.WND_TRIANGLE;
                  wnd{d} = (1:N)' / (N+1);
                case CS_EncParams.WND_SQRT_HANNING
                  wnd{d} = sqrt(0.5 + 0.5*cos((pi/(N+1))*(N:-1:1)'));
                case CS_EncParams.WND_SQRT_TRIANGLE
                  wnd{d} = sqrt((1:N)' / (N+1));
                otherwise
                  error('Unknown window type');
              end
            end
          end
        end
        
       function nxt_blk_indx = calcNxtIndx(obj, blk_indx)
            blk_cnt = obj.calcBlkCnt();
            len_blk_indx = length(blk_indx);
            indx_offset = 3 - len_blk_indx;
            nxbl = blk_indx;
            nxt_blk_indx = [];
            for k=1:len_blk_indx
                kk = k + indx_offset;
                if blk_indx(k) < blk_cnt(kk)
                    nxt_blk_indx = nxbl;
                    nxt_blk_indx(k) = nxbl(k)+1;
                    break;
                else
                    nxbl(k)=1;
                end
            end
        end
        
        function blk = interpolate(obj, blk)
          if iscell(blk)
            for k=2:size(obj.blk_size,1)
              blk{k} = obj.interpolate(blk{k});
            end
          else
            for dim=1:3
              uvr = double(obj.uv_ratio(dim));
              if uvr == 1
                continue;
              end
              wgt0 = (uvr:-1:1)/uvr;
              wgt1 = 1 - wgt0;
              sz_in = size(blk);
              sz_slc = sz_in;
              sz_slc(dim)=1;
              blk0 = blk;
              edge_indcs_1 = md_slice_indc(sz_in, dim, sz_in(dim));
              %duplicate end edge;
              blk1 = cat(dim, blk, reshape(blk(edge_indcs_1),sz_slc));
              edge_indcs_0 = md_slice_indc(size(blk1), dim, 1);
              blk1 = blk1(:);
              blk1(edge_indcs_0) = []; % remove first edge
              
              sz_out = sz_in;
              sz_out(dim) = sz_in(dim) * uvr;
              blk = zeros(sz_out);
              blk = blk(:);
              for k = 1:uvr
                indcs = md_slice_indc(sz_out, dim, k:uvr:sz_out(dim));
                blk(indcs) = wgt0(k)*blk0(:) + wgt1(k)*blk1;
              end
              blk = reshape(blk, sz_out);
            end
          end
        end
        
        function blk = undoInterpolate(obj, blk)
          if iscell(blk)
            for k=2:size(obj.blk_size,1)
              blk{k} = obj.undoInterpolate(blk{k});
            end
          else
            blk = blk(:,:,(1:obj.uv_ratio(3):size(blk,3)));
            blk = blk(:,(1:obj.uv_ratio(2):size(blk,2)),:);
            blk = blk((1:obj.uv_ratio(1):size(blk,1)),:,:);
          end
        end
        
        function blk_ext = extendBlk(obj, blk, ofst)
          if iscell(blk)
            for k=2:size(obj.blk_size,1)
              blk{k} = obj.interpolate(blk{k});
            end
          else
            bsz = obj.blk_size(1,:);
            blk_ext = zeros(bsz);
            sz = ones(1,3);
            sz1 = size(blk);
            sz(1:length(sz1)) = sz1;
            bbgn = ofst + 1;
            bend = ofst + sz;
            blk_ext(bbgn(1):bend(1), bbgn(2):bend(2), bbgn(3):bend(3)) = ...
              double(blk);
            
            % Extend V
            for j=1:bbgn(1)-1
              blk_ext(j,bbgn(2):bend(2), bbgn(3):bend(3)) = ...
                blk_ext(bbgn(1),bbgn(2):bend(2), bbgn(3):bend(3));
            end
            for j = bend(1)+1:bsz(1)
              blk_ext(j,bbgn(2):bend(2), bbgn(3):bend(3)) = ...
                blk_ext(bend(1),bbgn(2):bend(2), bbgn(3):bend(3));
            end
            
            % extend H
            for j=1:bbgn(2)-1
              blk_ext(:,j, bbgn(3):bend(3)) = ...
                blk_ext(:,bbgn(2), bbgn(3):bend(3));
            end
            for j = bend(2)+1:bsz(2)
              blk_ext(:,j, bbgn(3):bend(3)) = ...
                blk_ext(:,bend(2), bbgn(3):bend(3));
            end
            
            % extend T
            for j=1:bbgn(3)-1
              blk_ext(:,:,j) = blk_ext(:,:,bbgn(3));
            end
            for j = bend(3)+1:bsz(3)
              blk_ext(:,:,j) = blk_ext(:,:,bend(3));
            end
          end
       end
        
       function blk = undoExtendBlk(obj, blk, blk_ofst, blk_len)
         if iscell(blk)
           for k=1:size(obj.blk_size,1)
             blk{k} = obj.undoExtendBlk(blk{k}, blk_ofst, blk_len);
           end
         else
           bbgn = blk_ofst+1;
           bend = blk_ofst + blk_len;
           blk = blk(bbgn(1):bend(1),bbgn(2):bend(2),bbgn(3):bend(3));
         end
       end
       
       function mtrx = getUnInterpolateMtrx(obj, blk_indx)
           [~,~,blk_len,~,~,~] = obj.blkPosition(blk_indx);
           inp_len = prod(blk_len(1,:),2);
           blk = reshape(1:inp_len, blk_len(1,:));
           blk = blk(1:obj.uv_ratio(1):end, 1:obj.uv_ratio(2):end, ...
               1:obj.uv_ratio(3):end);
           blk = blk(:);
           if length(blk) == inp_len
               mtrx = SensingMatrixUnit(inp_len);
           else
               mtrx = SensingMatrixSelect(blk, inp_len);
           end
       end
       
       function mtrx = getInterpolateMtrx(obj, blk_indx)
            mtrx = [];
            [~,~,blk_len,~,~,~] = obj.blkPosition(blk_indx);
            inp_len = prod(blk_len(2,:),2);
            blk = reshape(1:inp_len, blk_len(2,:));
            for dim=1:3
                uvr = double(obj.uv_ratio(dim));
                wgt0 = (uvr:-1:1)/uvr;
                wgt1 = 1 - wgt0;
                sz_in = size(blk);
                sz_slc = sz_in;
                sz_slc(dim)=1;
                blk0 = blk(:);

                %duplicate end edge and remove beginning edge
                edge_indcs_1 = md_slice_indc(sz_in, dim, sz_in(dim));
                blk1 = cat(dim, blk, reshape(blk(edge_indcs_1),sz_slc));
                edge_indcs_0 = md_slice_indc(size(blk1), dim, 1);
                blk1 = blk1(:);
                blk1(edge_indcs_0) = []; % remove first edge
                
                sz_out = sz_in;
                sz_out(dim) = sz_in(dim) * uvr;
                out_len = prod(sz_out,2);
                r_ind = zeros(out_len*2,1);
                c_ind = zeros(out_len*2,1);
                w_ind = zeros(out_len*2,1);
                n_ind = 0;
                uv_len = 2*inp_len;
                
                for k=1:uvr
                    out_slc = md_slice_indc(sz_out, dim, k:uvr:sz_out(dim));
                    r_ind(n_ind+1:n_ind+uv_len) = [out_slc;out_slc];
                    c_ind(n_ind+1:n_ind+uv_len) = [blk0;blk1];
                    w_ind(n_ind+1:n_ind+uv_len) = [wgt0(k)*ones(inp_len,1);...
                        wgt1(k)*ones(inp_len,1)];
                    n_ind = n_ind + 2*inp_len;
                end
                
                intr_mtrx = sparse(r_ind,c_ind,w_ind);
                if isempty(mtrx)
                    mtrx = intr_mtrx;
                else
                    mtrx = intr_mtrx * mtrx;
                end
                
                inp_len = out_len;
                blk = reshape(1:out_len, sz_out);
            end
            
            if isempty(mtrx)
                mtrx = scaler(numel(blk),1);
            else
                mtrx = SensingMatrixMatlab(mtrx);
            end
        end
        
        function mtrx = getUnExtendMtrx(obj, blk_indx)
            [~,~,blk_len,~,~,blk_ofst] = obj.blkPosition(blk_indx);
            inp_len = prod(obj.blk_size(1,:),2);
            blk = reshape(1:inp_len, obj.blk_size(1,:));
            bbgn = blk_ofst(1,:)+1;
            bend = blk_ofst(1,:) + blk_len(1,:);
            blk = blk(bbgn(1):bend(1),bbgn(2):bend(2),bbgn(3):bend(3));
            blk = blk(:);
            if length(blk) == inp_len
                mtrx = SensingMatrixUnit(inp_len);
            else
                mtrx = SensingMatrixSelect(blk, inp_len);
            end
        end
        
        % extend end blocks (first or last) to fill the edges with
        % nearest value
        function mtrx = getExtendMtrx(obj, blk_indx)
            [~,~,blk_len,~,~,blk_ofst] = obj.blkPosition(blk_indx);
            mtrx = [];
            blk_len = blk_len(1,:);
            blk_ofst = blk_ofst(1,:);
            bbgn = blk_ofst(1,:)+1;
            bend = blk_ofst(1,:)+blk_len(1,:);
            inp_len = prod(blk_len,2);
            blk = reshape(1:inp_len, blk_len(1,:));
            
            for dim=1:3
                if blk_len(dim) == obj.blk_size(1,dim)
                    continue;
                end
                sz_in = size(blk);
                sz_out = sz_in;
                sz_out(dim) = obj.blk_size(1,dim);
                out_len = prod(sz_out,2);
                inp_blk = zeros(sz_out);
                inp_blk_mid = md_slice_indc(sz_out, dim, bbgn(dim):bend(dim));
                inp_blk(inp_blk_mid) = blk(:);
                if bbgn(dim) > 1
                    blk_slc = md_slice_indc(sz_in, dim, 1);
                    for k=1:bbgn(dim)-1
                        out_slc = md_slice_indc(sz_out, dim, k);
                        inp_blk(out_slc) = blk(blk_slc);
                    end
                end
                if bend(dim) < sz_out(dim)
                    blk_slc = md_slice_indc(sz_in, dim, sz_in(dim));
                    for k=(bend(dim)+1):sz_out(dim)
                        out_slc = md_slice_indc(sz_out, dim, k);
                        inp_blk(out_slc) = blk(blk_slc);
                    end
                end
                
                extnd_mtrx = sparse(1:out_len, inp_blk(:),1);
                if isempty(mtrx)
                    mtrx = extnd_mtrx;
                else
                    mtrx = extnd_mtrx * mtrx;
                end
                    
                blk = reshape(1:out_len, sz_out);
            end
            
            if isempty(mtrx)
                mtrx = SensingMatrixUnit(numel(blk));
            else
                mtrx = SensingMatrixMatlab(mtrx);
            end
        end
    end
   
    methods (Access=protected, Static)
      
       function blk = windowBlk(blk, wnd, is_first, is_last)
         if iscell(blk)
           for k=1:length(blk);
             blk{k} = VidBlocker.windowBlk(blk{k}, wnd, is_first, is_last);
           end
         else
           
           sz = size(blk);
           
           if isempty(wnd)
             return
           end
           
           for k=1:3
             if isempty(wnd.b{k})
               continue;
             end
             if ~is_first(k)
               wgt_b = wnd.b{k};
               for i=1:length(wgt_b)
                 slc_b = md_slice_indc(sz, k, i);
                 blk(slc_b) = blk(slc_b) .* wgt_b(i);
               end
             end
             if ~is_last(k)
               wgt_f = wnd.f{k};
               l_wgt = length(wgt_f);
               for i=1:l_wgt
                 slc_f = md_slice_indc(size(blk), k, sz(k)-l_wgt+i);
                 blk(slc_f) = blk(slc_f) .* wgt_f(i);
               end
             end
           end
         end
       end
       
       function blk = unWindowBlk(blk, wnd, is_first, is_last)
         if iscell(blk)
           for k=1:length(blk);
             blk{k} = VidBlocker.unWindowBlk(blk{k}, wnd, is_first, is_last);
           end
         else
           
           sz = size(blk);
           
           if isempty(wnd)
             return
           end
           
           for k=1:3
             if isempty(wnd.b{k})
               continue;
             end
             if ~is_first(k)
               wgt_b = wnd.b{k};
               for i=1:length(wgt_b)
                 slc_b = md_slice_indc(sz, k, i);
                 blk(slc_b) = blk(slc_b) ./wgt_b(i);
               end
             end
             if ~is_last(k)
               wgt_f = wnd.f{k};
               l_wgt = length(wgt_f);
               for i=1:l_wgt
                 slc_f = md_slice_indc(size(blk), k, sz(k)-l_wgt+i);
                 blk(slc_f) = blk(slc_f) ./ wgt_f(i);
               end
             end
           end
         end
       end
    end
    
end

