classdef SensingMatrixSRM < SensingMatrixCascade & SensingMatrixRnd
  %SensingMatrixSRM is an implmementation of Structured Random Matrix
  % This matrix is a cascade of 4 matrices: S*T*R*Z, where:
  %   S (select) - A selection matrix
  %   T (transform) - a transform (usually a fast one)
  %   R (randomizer) - a randomizer signal
  %   Z (zero-padder) extends the input signal to length order by
  %                  zero-padding
  
  properties
    rndmzr_spec;
    blk_dims;
    rndmzr;
    trnsfrm;
  end
  
    properties (Constant)
      % These constants are used to define the
      % type of the signal randomization generatd by makeRandomizer:
      RNDMZR_NONE = 0;  % no randomization
      RNDMZR_LCL = 1; % Local randomization
      RNDMZR_SHFT = 2; % circular shift randomization
      RNDMZR_GLBL = 3; % Glocal randomization
      
      % These constants define the method of selecting n_rows measurement
      % out of t_order (transform order) transform coefficients output
      SLCT_NONE = 0; % Select the first n_rows elements
      SLCT_ARBT = 1; % Random selection, no repetitions, uniform distribution
      SLCT_SHFT = 2; % Select a contiguous sequence at a random starting point
                     % wrap around.
      SLCT_LCLS = 3;
      SLCT_GLBL = 4;
      
      
    end
  methods
    function obj = SensingMatrixSRM(varargin)
      % Constructor
      %   Input. The matrices here can be actual SenseMatrix objects or structs
      %   with fields 'name', 'args', for use in SensingMatrix.construct()
      %   Input arguments:
      %     num_rows - number of rows in the matrix
      %     num_columns - number of columns in the matrix
      %     rnd_seed - Defines the random number generator. Can be either a
      %       a struct or a non-negative integer. If it is a
      %       struct it has the fields:
      %         seed - Seed of the random number generator
      %                non-negative integer)
      %         type - type of the generator. Can be a character
      %                string, in which case the generator is a
      %                RandStream of this type, or one of 1 or 2,
      %                in which case the generator is a RandCStrm.
      %                If the value is 2, each random number
      %                generation is compared to that generated by
      %                default_rnd_type.
      %        If rnd_seed is a a non-negative integer it is taken as the
      %        seed and the type is SensingMartixRnd.default_rnd_type.
      %     slct - select matrix
      %     tfrm - transform matrix
      %     spec - An array specifyng the randomizer. spec may be
      %            of length 1 for full randomization, or length 3 for
      %            structured randomization. In the latter case, spec(1),
      %            spec(2), spec(3), specify the spatial, temporal and
      %            color block randomizations, The values of spec are one
      %            of RNDMZR_xxx.
      %     dims - (Needed only for structured randomization). An array of
      %            size 3, containing the dimensions of a block (V,H,T).
      %            In full randomization, dims can be prsent and can either
      %            be the scalar obj.sqrOrder() or the block dimensions (V,H,T).
      obj.set(varargin);
    end
    
    function set(varargin)
      %   Input. The matrices can be actual SenseMatrix objects or structs
      %   with fields 'name', 'args', for use in SensingMatrix.construct():
      %   Input arguments:
      %     num_rows - number of rows in the matrix
      %     num_columns - number of columns in the matrix
      %     rnd_seed - Defines the random number generator. Can be either a
      %       a struct or a non-negative integer. If it is a
      %       struct it has the fields:
      %         seed - Seed of the random number generator
      %                non-negative integer)
      %         type - type of the generator. Can be a character
      %                string, in which case the generator is a
      %                RandStream of this type, or one of 1 or 2,
      %                in which case the generator is a RandCStrm.
      %                If the value is 2, each random number
      %                generation is compared to that generated by
      %                default_rnd_type.
      %        If rnd_seed is a a non-negative integer it is taken as the
      %        seed and the type is SensingMartixRnd.default_rnd_type.
      %     slct - select matrix
      %     tfrm - transform matrix
      %     rnd_mode - An array specifyng the randomizer. spec may be
      %            of length 1 for full randomization, or length 3 for
      %            structured randomization. In the latter case, spec(1),
      %            spec(2), spec(3), specify the spatial, temporal and
      %            color block randomizations, The values of spec are one
      %            of RNDMZR_xxx.
      %     dims - (Needed only for structured randomization). An array of
      %            size 3, containing the dimensions of a block (V,H,T).
      %            In full randomization, dims can be prsent and can either
      %            be the scalar obj.sqrOrder() or the block dimensions (V,H,T).
      varargin = parseInitArgs(varargin, {'num_rows', 'num_columns',...
        'rnd_seed', 'slct', 'trfm', 'rnd_mode', 'dims'});
      obj.setensingMatrixSRM(varargin{:});
    end
    
    function ord = sqrOrder(obj)
      ord = obj.trnsfrm.nCols();
    end
      
  end
  
  methods (Access=protected)
    function setSensingMatrixSRM(obj, num_rows, num_columns, rnd_seed, ...
        slct, tfrm, rnd_mode, dims)
      %   Input. The matrices can be actual SenseMatrix objects or structs
      %   with fields 'name', 'args', for use in SensingMatrix.construct():
      %   Input arguments:
      %     num_rows - number of rows in the matrix
      %     num_columns - number of columns in the matrix
      %     rnd_seed - Defines the random number generator. Can be either a
      %       a struct or a non-negative integer. If it is a
      %       struct it has the fields:
      %         seed - Seed of the random number generator
      %                non-negative integer)
      %         type - type of the generator. Can be a character
      %                string, in which case the generator is a
      %                RandStream of this type, or one of 1 or 2,
      %                in which case the generator is a RandCStrm.
      %                If the value is 2, each random number
      %                generation is compared to that generated by
      %                default_rnd_type.
      %        If rnd_seed is a a non-negative integer it is taken as the
      %        seed and the type is SensingMartixRnd.default_rnd_type.
      %     slct - select matrix
      %     tfrm - transform matrix
      %     rnd_mode - An array specifyng the randomizer. spec may be
      %            of length 1 for full randomization, or length 3 for
      %            structured randomization. In the latter case, spec(1),
      %            spec(2), spec(3), specify the spatial, temporal and
      %            color block randomizations, The values of spec are one
      %            of RNDMZR_xxx.
      %     dims - (Needed only for structured randomization). An array of
      %            size 3, containing the dimensions of a block (V,H,T).
      %            In full randomization, dims can be prsent and can either
      %            be the scalar obj.sqrOrder() or the block dimensions (V,H,T).
      if nargin < 3
        rnd_args = {};
      elseif nargin < 4
        rnd_args = {num_rows, num_columns};
      else
        rnd_args = {num_rows, num_columns, rnd_seed};
      end
      obj.setSensingMatrixRnd(rnd_args{:});
      
      if nargin <= 4
        return
      end
      obj.trnsfrm = trfm;
      order = obj.sqrOrder();
      
      mtrx = cell(1,4);
      n_mtrx = 0;
      
      if ~isa(slct, 'SensingMatrixUnit')
        n_mtrx = n_mtrx+1;
        mtrx(n_mtrx) = slct;
      end
      
      n_mtrx = n_mtrx+1;
      mtrx(n_mtrx) = tfrm;
      
      if nargin < 8
        if length(rnd_mode) ~= 1
          error('dims must be specified when length(spec) > 1');
        else
          dims = order;
        end
      end
     
      obj.makeRandomizer(rnd_mode, dims);
      if ~isa(obj.rndmzr, 'SensingMatrixUnit')
        n_mtrx = n_mtrx+1;
        mtrx(n_mtrx) = obj.rndmzr;
      end
      
      if obj.sqrOrder() ~= num_columns
        n_mtrx = n_mtrx+1;
        mtrx(n_mtrx) = SensingMatrixSelectRange(1, num_columns, order);
      end
      
      obj.setSensingMatrixCascade(mtrx(1:n_mtrx));
      
    end
    
    function makeRandomizer(obj, spec, dims)
      % makeRandomizer generates a randomizer matrix of dimension
      % obj.nCols(). The randomization can be full, in which case
      % the whole input vector is randomized, or structured, in which case
      % the randomization is done along certain dimensions of the signal:
      % Spatial, temporal or color block. Along each dimension, all elements
      % are shuffled together.
      %   Input arguments:
      %     obj - this object
      %     spec - An array specifyng the randomizer. spec may be
      %            of length 1 for full randomization, or length 3 for
      %            structured randomization. In the latter case, spec(1),
      %            spec(2), spec(3), specify the spatial, temporal and
      %            color block randomizations, The values of spec are one
      %            of RNDMZR_xxx.
      %     dims - (Needed only for structured randomization). An array of
      %            size 3, containing the dimensions of a block (V,H,T).
      %            In full randomization, dims can be prsent and can either
      %            be the scalar obj.sqrOrder() or the block dimensions (V,H,T).
      
      obj.rndmzr_spec = spec;
      dims = obj.toIndex(dims);
      obj.blk_dims = dims;
      
      order = obj.sqrOrder();
      ncl = obj.nCols();
      
      switch length(spec)
        case 1
          obj.rndmzr = build_randomizer(spec, order);
          return
        case 3
          % break to continuation.
        otherwise
          error('length of spec should be 1 or 3');
      end
      
      dms = [dims(1)*dims(2), dims(3), 0];
      dms(3) = ncl/(dms(1)*dms(2));
      mtrx = cell(1,3);
      
      if order == ncl || spec(3) == SensingMatrixRnd.RNDMZR_NONE ||...
          spec(3) == SensingMatrixRnd.RNDMZR_LCL
        for k=1:3
          mtrx{4-k} = build_randomizer(spec(k), dms(k));
        end
        rndm = SensingMatrixKron.constructKron(mtrx);
        if order == ncl
          obj.rndmzr = rndm;
        else
          obj.rndmzr = SensingMatrixBlkDiag.constructBlkDiag({rndm,...
            SensingMatrixUnit(order-ncl)});
        end
      else
        for k=1:2
          mtrx{4-k} = build_randomizer(spec(k), dms(k));
        end
        lng = dms(3)+1;
        mtx = cell(1,lng);
        mtx{1} = ensingMatrixKron.constructKron(mtrx(2:3));
        for k=2:dms(3)
          mtx{k} = mtx{1}.copy();
        end
        mtx{lng} = SensingMatrixUnit(order);
        switch spec(3)
          case SensingMatrixRnd.RNDMZR_SHFT
            bgn = double(obj.rnd_strm.randi(lng,1));
            mtx = [mtx(bgn:end) mtx(1,bgn-1)];
          case SensingMatrixRnd.RNDMZR_GLBL
            mtx = mtx(obj.rnd_strm.randperm(ordr));
          otherwise
            error('Unknown randomization mode: %d', mode);
        end
        obj.rndmzr = SensingMatrixBlkDiag.constructBlkDiag(mtx);
      end
      
      function mtx = build_randomizer(mode, ordr)
        % A nested function for building a randomizer along one
        % direction.
        switch mode
          case SensingMatrixRnd.RNDMZR_NONE
            mtx = SensingMatrixUnit(ordr);
          case SensingMatrixRnd.RNDMZR_LCL
            mtx = SensingMatrixDiag(double(obj.rnd_strm.randi([0,1],[1,ordr])));
          case SensingMatrixRnd.RNDMZR_SHFT
            bgn = double(obj.rnd_strm.randi(ordr,1));
            mtx = SensingMatrixSelectRange(bgn, 0, ordr);
          case SensingMatrixRnd.RNDMZR_GLBL
            mtx = SensingMatrixSelect(obj.rnd_strm.randperm(ordr), ordr);
          otherwise
            error('Unknown randomization mode: %d', mode);
        end
      end
    end
    
    function setUseGpu(obj,val)
      obj.setUseGpu@SensingMatrixCascade(val);
      if isa(obj.rndmzr, 'SensingMatrix')
        obj.rndmzr.setUseGpu(val);
      end
      if isa(obj.trnsfrm, 'SensingMatrix')
        obj.trnsfrm.setUseGpu(val);
      end
    end
    
    function setUseSingle(obj,val)
      obj.setUseSingle@SensingMatrixCascade(val);
      if isa(obj.rndmzr, 'SensingMatrix')
        obj.rndmzr.setUseSingle(val);
      end
      if isa(obj.trnsfrm, 'SensingMatrix')
        obj.trnsfrm.setUseSingle(val);
      end
    end
    
    function setCastIndex(obj)
      obj.setCastIndex@SensingMatrixCascade();
      obj.blk_dims = obj.toIndex(obj.blk_dims);
    end
  end
  
end

