classdef CodeSource < matlab.mixin.Copyable
    % CodeSource is an abstract class representing an object from which code
    % can be read.
    % The source can be a memory array, a file, a socket, etc.  The only
    % requirement is that it has to support sequential reading.
    % In the code, unsigned integer has a variable size representation. The
    % unsigned integern is represented as a sequence of bytes in big endian
    % (more significant bytes first) form. In each bytes the lower 7 bits
    % contain vlue while the MSB is a continuation bit (1 for non-final
    % byte 0 for final byte).
    % Signed integers are also supported.  The code for a signed integer is in
    % a sign-magnitude form and similar to the code for unsigned integers,
    % except that the 2nd MSB of the last byte (bit 6) is the
    % sign bit - 1 for negative and 0 for non-negative.
    % Code is usually stored in a length-vlue format, meaning an unsigned
    % integer in the above representation indicating the code length
    % followed by a sequence of bytes of the specified length.  Usually the
    % length is preceded by a type (key) indicating a code of what it is. 
    
    properties (Constant)
        bits_tbl = [...
            0 0 0 0 0 0 0 0;...
            0 0 0 0 0 0 0 1;...
            0 0 0 0 0 0 1 0;...
            0 0 0 0 0 0 1 1;...
            0 0 0 0 0 1 0 0;...
            0 0 0 0 0 1 0 1;...
            0 0 0 0 0 1 1 0;...
            0 0 0 0 0 1 1 1;...
            0 0 0 0 1 0 0 0;...
            0 0 0 0 1 0 0 1;...
            0 0 0 0 1 0 1 0;...
            0 0 0 0 1 0 1 1;...
            0 0 0 0 1 1 0 0;...
            0 0 0 0 1 1 0 1;...
            0 0 0 0 1 1 1 0;...
            0 0 0 0 1 1 1 1;...
            0 0 0 1 0 0 0 0;...
            0 0 0 1 0 0 0 1;...
            0 0 0 1 0 0 1 0;...
            0 0 0 1 0 0 1 1;...
            0 0 0 1 0 1 0 0;...
            0 0 0 1 0 1 0 1;...
            0 0 0 1 0 1 1 0;...
            0 0 0 1 0 1 1 1;...
            0 0 0 1 1 0 0 0;...
            0 0 0 1 1 0 0 1;...
            0 0 0 1 1 0 1 0;...
            0 0 0 1 1 0 1 1;...
            0 0 0 1 1 1 0 0;...
            0 0 0 1 1 1 0 1;...
            0 0 0 1 1 1 1 0;...
            0 0 0 1 1 1 1 1;...
            0 0 1 0 0 0 0 0;...
            0 0 1 0 0 0 0 1;...
            0 0 1 0 0 0 1 0;...
            0 0 1 0 0 0 1 1;...
            0 0 1 0 0 1 0 0;...
            0 0 1 0 0 1 0 1;...
            0 0 1 0 0 1 1 0;...
            0 0 1 0 0 1 1 1;...
            0 0 1 0 1 0 0 0;...
            0 0 1 0 1 0 0 1;...
            0 0 1 0 1 0 1 0;...
            0 0 1 0 1 0 1 1;...
            0 0 1 0 1 1 0 0;...
            0 0 1 0 1 1 0 1;...
            0 0 1 0 1 1 1 0;...
            0 0 1 0 1 1 1 1;...
            0 0 1 1 0 0 0 0;...
            0 0 1 1 0 0 0 1;...
            0 0 1 1 0 0 1 0;...
            0 0 1 1 0 0 1 1;...
            0 0 1 1 0 1 0 0;...
            0 0 1 1 0 1 0 1;...
            0 0 1 1 0 1 1 0;...
            0 0 1 1 0 1 1 1;...
            0 0 1 1 1 0 0 0;...
            0 0 1 1 1 0 0 1;...
            0 0 1 1 1 0 1 0;...
            0 0 1 1 1 0 1 1;...
            0 0 1 1 1 1 0 0;...
            0 0 1 1 1 1 0 1;...
            0 0 1 1 1 1 1 0;...
            0 0 1 1 1 1 1 1;...
            0 1 0 0 0 0 0 0;...
            0 1 0 0 0 0 0 1;...
            0 1 0 0 0 0 1 0;...
            0 1 0 0 0 0 1 1;...
            0 1 0 0 0 1 0 0;...
            0 1 0 0 0 1 0 1;...
            0 1 0 0 0 1 1 0;...
            0 1 0 0 0 1 1 1;...
            0 1 0 0 1 0 0 0;...
            0 1 0 0 1 0 0 1;...
            0 1 0 0 1 0 1 0;...
            0 1 0 0 1 0 1 1;...
            0 1 0 0 1 1 0 0;...
            0 1 0 0 1 1 0 1;...
            0 1 0 0 1 1 1 0;...
            0 1 0 0 1 1 1 1;...
            0 1 0 1 0 0 0 0;...
            0 1 0 1 0 0 0 1;...
            0 1 0 1 0 0 1 0;...
            0 1 0 1 0 0 1 1;...
            0 1 0 1 0 1 0 0;...
            0 1 0 1 0 1 0 1;...
            0 1 0 1 0 1 1 0;...
            0 1 0 1 0 1 1 1;...
            0 1 0 1 1 0 0 0;...
            0 1 0 1 1 0 0 1;...
            0 1 0 1 1 0 1 0;...
            0 1 0 1 1 0 1 1;...
            0 1 0 1 1 1 0 0;...
            0 1 0 1 1 1 0 1;...
            0 1 0 1 1 1 1 0;...
            0 1 0 1 1 1 1 1;...
            0 1 1 0 0 0 0 0;...
            0 1 1 0 0 0 0 1;...
            0 1 1 0 0 0 1 0;...
            0 1 1 0 0 0 1 1;...
            0 1 1 0 0 1 0 0;...
            0 1 1 0 0 1 0 1;...
            0 1 1 0 0 1 1 0;...
            0 1 1 0 0 1 1 1;...
            0 1 1 0 1 0 0 0;...
            0 1 1 0 1 0 0 1;...
            0 1 1 0 1 0 1 0;...
            0 1 1 0 1 0 1 1;...
            0 1 1 0 1 1 0 0;...
            0 1 1 0 1 1 0 1;...
            0 1 1 0 1 1 1 0;...
            0 1 1 0 1 1 1 1;...
            0 1 1 1 0 0 0 0;...
            0 1 1 1 0 0 0 1;...
            0 1 1 1 0 0 1 0;...
            0 1 1 1 0 0 1 1;...
            0 1 1 1 0 1 0 0;...
            0 1 1 1 0 1 0 1;...
            0 1 1 1 0 1 1 0;...
            0 1 1 1 0 1 1 1;...
            0 1 1 1 1 0 0 0;...
            0 1 1 1 1 0 0 1;...
            0 1 1 1 1 0 1 0;...
            0 1 1 1 1 0 1 1;...
            0 1 1 1 1 1 0 0;...
            0 1 1 1 1 1 0 1;...
            0 1 1 1 1 1 1 0;...
            0 1 1 1 1 1 1 1;...
            1 0 0 0 0 0 0 0;...
            1 0 0 0 0 0 0 1;...
            1 0 0 0 0 0 1 0;...
            1 0 0 0 0 0 1 1;...
            1 0 0 0 0 1 0 0;...
            1 0 0 0 0 1 0 1;...
            1 0 0 0 0 1 1 0;...
            1 0 0 0 0 1 1 1;...
            1 0 0 0 1 0 0 0;...
            1 0 0 0 1 0 0 1;...
            1 0 0 0 1 0 1 0;...
            1 0 0 0 1 0 1 1;...
            1 0 0 0 1 1 0 0;...
            1 0 0 0 1 1 0 1;...
            1 0 0 0 1 1 1 0;...
            1 0 0 0 1 1 1 1;...
            1 0 0 1 0 0 0 0;...
            1 0 0 1 0 0 0 1;...
            1 0 0 1 0 0 1 0;...
            1 0 0 1 0 0 1 1;...
            1 0 0 1 0 1 0 0;...
            1 0 0 1 0 1 0 1;...
            1 0 0 1 0 1 1 0;...
            1 0 0 1 0 1 1 1;...
            1 0 0 1 1 0 0 0;...
            1 0 0 1 1 0 0 1;...
            1 0 0 1 1 0 1 0;...
            1 0 0 1 1 0 1 1;...
            1 0 0 1 1 1 0 0;...
            1 0 0 1 1 1 0 1;...
            1 0 0 1 1 1 1 0;...
            1 0 0 1 1 1 1 1;...
            1 0 1 0 0 0 0 0;...
            1 0 1 0 0 0 0 1;...
            1 0 1 0 0 0 1 0;...
            1 0 1 0 0 0 1 1;...
            1 0 1 0 0 1 0 0;...
            1 0 1 0 0 1 0 1;...
            1 0 1 0 0 1 1 0;...
            1 0 1 0 0 1 1 1;...
            1 0 1 0 1 0 0 0;...
            1 0 1 0 1 0 0 1;...
            1 0 1 0 1 0 1 0;...
            1 0 1 0 1 0 1 1;...
            1 0 1 0 1 1 0 0;...
            1 0 1 0 1 1 0 1;...
            1 0 1 0 1 1 1 0;...
            1 0 1 0 1 1 1 1;...
            1 0 1 1 0 0 0 0;...
            1 0 1 1 0 0 0 1;...
            1 0 1 1 0 0 1 0;...
            1 0 1 1 0 0 1 1;...
            1 0 1 1 0 1 0 0;...
            1 0 1 1 0 1 0 1;...
            1 0 1 1 0 1 1 0;...
            1 0 1 1 0 1 1 1;...
            1 0 1 1 1 0 0 0;...
            1 0 1 1 1 0 0 1;...
            1 0 1 1 1 0 1 0;...
            1 0 1 1 1 0 1 1;...
            1 0 1 1 1 1 0 0;...
            1 0 1 1 1 1 0 1;...
            1 0 1 1 1 1 1 0;...
            1 0 1 1 1 1 1 1;...
            1 1 0 0 0 0 0 0;...
            1 1 0 0 0 0 0 1;...
            1 1 0 0 0 0 1 0;...
            1 1 0 0 0 0 1 1;...
            1 1 0 0 0 1 0 0;...
            1 1 0 0 0 1 0 1;...
            1 1 0 0 0 1 1 0;...
            1 1 0 0 0 1 1 1;...
            1 1 0 0 1 0 0 0;...
            1 1 0 0 1 0 0 1;...
            1 1 0 0 1 0 1 0;...
            1 1 0 0 1 0 1 1;...
            1 1 0 0 1 1 0 0;...
            1 1 0 0 1 1 0 1;...
            1 1 0 0 1 1 1 0;...
            1 1 0 0 1 1 1 1;...
            1 1 0 1 0 0 0 0;...
            1 1 0 1 0 0 0 1;...
            1 1 0 1 0 0 1 0;...
            1 1 0 1 0 0 1 1;...
            1 1 0 1 0 1 0 0;...
            1 1 0 1 0 1 0 1;...
            1 1 0 1 0 1 1 0;...
            1 1 0 1 0 1 1 1;...
            1 1 0 1 1 0 0 0;...
            1 1 0 1 1 0 0 1;...
            1 1 0 1 1 0 1 0;...
            1 1 0 1 1 0 1 1;...
            1 1 0 1 1 1 0 0;...
            1 1 0 1 1 1 0 1;...
            1 1 0 1 1 1 1 0;...
            1 1 0 1 1 1 1 1;...
            1 1 1 0 0 0 0 0;...
            1 1 1 0 0 0 0 1;...
            1 1 1 0 0 0 1 0;...
            1 1 1 0 0 0 1 1;...
            1 1 1 0 0 1 0 0;...
            1 1 1 0 0 1 0 1;...
            1 1 1 0 0 1 1 0;...
            1 1 1 0 0 1 1 1;...
            1 1 1 0 1 0 0 0;...
            1 1 1 0 1 0 0 1;...
            1 1 1 0 1 0 1 0;...
            1 1 1 0 1 0 1 1;...
            1 1 1 0 1 1 0 0;...
            1 1 1 0 1 1 0 1;...
            1 1 1 0 1 1 1 0;...
            1 1 1 0 1 1 1 1;...
            1 1 1 1 0 0 0 0;...
            1 1 1 1 0 0 0 1;...
            1 1 1 1 0 0 1 0;...
            1 1 1 1 0 0 1 1;...
            1 1 1 1 0 1 0 0;...
            1 1 1 1 0 1 0 1;...
            1 1 1 1 0 1 1 0;...
            1 1 1 1 0 1 1 1;...
            1 1 1 1 1 0 0 0;...
            1 1 1 1 1 0 0 1;...
            1 1 1 1 1 0 1 0;...
            1 1 1 1 1 0 1 1;...
            1 1 1 1 1 1 0 0;...
            1 1 1 1 1 1 0 1;...
            1 1 1 1 1 1 1 0;...
            1 1 1 1 1 1 1 1 ...
            ];
    end
    
    properties
      typ_list = CodeElementTypeList;
    end
    
    methods (Abstract)
        % read - Read cnt bytes (uint8) and return them in code. If EOD is
        % encountered before any byte are read, -1 is returned.  If an
        % error occured or EOD encountered after some bytes were read an 
        % error string (char) is returned.  After an error
        % the state of the object is undefined.
        code = read(obj, cnt)
    end
    
    methods
        % readUInt  - read an unsigned integer (up to 64 bit range) or 
        % vector of integers.
        % Input:
        %    obj - this object
        %    max_cnt - (optional) maximal number of byte to read for parsing the
        %    integer.
        %    siz - (optional) size of output (an array, e.g. [5,1]).
        % Output:
        %    val - normally the integer which was read (value or vector).
        %          -1 if EOD was encountered before any byte was read. An 
        %          error string if an error occurred or if EOD was 
        %          encountered after some bytes were read or if max_cnt was 
        %          exceeded.
        %    cnt - Number of bytes read.
        function [val, cnt] = readUInt(obj, max_cnt, siz)
            if nargin < 3
                siz = [1,1];
                if nargin < 2
                    max_cnt = inf;
                end
            end
            cnt = 0;
            if max_cnt <= 0 && min(siz)
                val = -1;
                return
            end
            
            val = uint64(zeros(siz));
            if isempty(val)
                return
            end
   
            [buf, indcs, cnt] = obj.readSeqs(max_cnt, numel(val));
            if ischar(buf) || (numel(buf)==1 && buf == -1)
                val = buf;
                return;
            end
            
            % clear the continuation bit
            buf = bitand(buf,uint8(127));
            
            bgn = [1 (indcs(1:end-1)+1)];
            val(:) = obj.compSeqs(buf, indcs, bgn);
        end
        
        % readSInt  - read an unsigned value (as double).
        % Input:
        %    obj - this object
        %    max_cnt - (optional) maximal number of byte to read for parsing 
        %              the integer.
        %    siz - (optional) size of output (an array, e.g. [5,1]).
        % Output:
        %    val - normally the integers which were read. '' if EOD was
        %          encountered before any byte was read. An error string if
        %          an error occurred or if EOD was encountered after some
        %          bytes were read or if max_cnt was exceeded.
        %    cnt - Number of bytes read.
       function [val, cnt] = readSInt(obj, max_cnt,siz)
            if nargin < 3
                siz = [1,1];
                if nargin < 2
                    max_cnt = inf;
                end
            end
            cnt = 0;
            if max_cnt <= 0 && min(siz)
                val = '';
                return
            end
            
            val = int64(zeros(siz));
            if isempty(val)
                return
            end
            
            [buf, indcs, cnt] = obj.readSeqs(max_cnt, numel(val));
            if ischar(buf)
                val = buf;
                return;
            elseif  numel(buf)==1 && buf == -1
                val = '';
                return
            end
            
            % clear the continuation bit
            buf = bitand(buf,uint8(127));

            bgn = [1 (indcs(1:end-1)+1)];
            ngtv = find(buf(bgn) >= uint8(64));
            buf(bgn) = bitand(buf(bgn),uint8(63));
            val(:) = int64(obj.compSeqs(buf, indcs, bgn));
            val(ngtv) = -val(ngtv);
            
       end
           
        % readNumber - read a number of vector (float)
        % Input
        %    obj - this object
        %    max_cnt - (optional) maximal number of byte to read for parsing 
        %              the integer.
        %    siz - (optional) size of output (an array, e.g. [5,1]).
        % Output:
        %    val - normally the numbers which were read. '' if EOD was
        %          encountered before any byte was read. An error string if
        %          an error occurred or if EOD was encountered after some
        %          bytes were read or if max_cnt was exceeded.
        %    cnt - Number of bytes read.
        function [val, cnt] = readNumber(obj, max_cnt, siz)
            if nargin < 3
                siz = [1,1];
            end
            if nargin < 2
                max_cnt = inf;
            end
        
            [f, cnt] = obj.readSInt(max_cnt, siz);
            if ischar(f)
                val = f;
                return
            end
            [e, n] = obj.readSInt(max_cnt-cnt, siz);
            if ischar(e)
                if isempty(e)
                    e = 'EOD in the middle of a number';
                end
                val = e;
                return
            end
            cnt = cnt + n;
            val = pow2(double(f),double(e));
        end
        
        function [bitvals, cnt] = readBits(obj, max_cnt, n_bits)
          % readBits - read array of binary values as a series of bytes. The
          % reading includes reading the length of the array
          % Input
          %   obj - this object.
          %   max_cnt - (optional) maximal number of byte to read .
          %   bitvals - an array of values, where non-zero is interpreted as a 1 bit
          %   and zero a 0 bit.
          %   n_bits - (optional) if present the output bitvals is
          %     assumed to be integers of n_bits bits.
          % Output
          %   bitvals - normally an array (horizontal) of uint8 containing
          %              the bits values or an error string if an error occured.
          %   cnt - Number of bytes read.
          if nargin < 2
            max_cnt = inf;
          end
          
          [len_b, cnt] = obj.readUInt(max_cnt);
          if ischar(len_b)
            bitvals=len_b;
            return
          elseif len_b == -1
            bitvals = 'EOD found';
            return
          else
            len_b = double(len_b);
            max_cnt = max_cnt - cnt;
          end
          
          if nargin < 3
            [bitvals, len] = obj.readBitsArray(len_b, max_cnt);
          else
            [bitvals, len] = obj.readBitsArray(len_b, max_cnt, n_bits);
          end
          if ~ischar(bitvals)
            cnt = cnt + len;
          end
        end
        
         function [bitvals, cnt] = readBitsArray(obj, len_b, max_cnt, n_bits)
           % readBits - read array of binary values as a series of bytes. The
           % length of the array is provided
           % Input
           %   obj - this object.
           %   len_b - length of the array
           %   max_cnt - (optional) maximal number of byte to read .
           %   n_bits - (optional) if present the output bitvals is
           %     assumed to be integers of n_bits bits.
           % Output
           %   bitvals - normally an array (horizontal) of uint8 containing
           %              the bits values or an error string if an error occured.
           %   cnt - Number of bytes read.
           if nargin < 3
             max_cnt = inf;
           end
           
           len_b = double(len_b);
           cnt = 0;
           
           if nargin >= 4
             [bitvals, cnt] = readBitsArray(obj, len_b*n_bits, max_cnt);
             if ischar(bitvals)
               return;
             end
             bitvals = reshape(bitvals, [len_b, n_bits]);
             for k=n_bits-1:-1:1
               bitvals(:,k) = bitvals(:,k) + 2*bitvals(:,k+1);
             end
             bitvals = bitvals(:,1);
             return
           end
           
           bitvals = zeros(1,len_b);
           if len_b == 0; return; end
           
           len_a = ceil(len_b/8);
           if len_a > max_cnt
             bitvals = 'Allowed number of bytes exceeded';
           end
           
           b_array = obj.read(len_a);
           if ischar(b_array)
             bitvals = b_array;
             return
           elseif isscalar(b_array) && b_array == -1
             bitvals = 'EOD found';
             return
           else
             cnt = len_a;
           end
           
           remainder = rem(len_b, 8);
           k_val = remainder + 1;
           if remainder
             bt = uint32(b_array(1));
             bitvals(1:remainder) = obj.bits_tbl((bt+1), (9-remainder):8);
             bgn_array = 2;
           else
             bgn_array = 1;
           end
           
           for k_array = bgn_array:len_a
             bt = uint32(b_array(k_array));
             bitvals(k_val:k_val+7) = obj.bits_tbl(bt+1,:);
             k_val = k_val+8;
           end
         end
         
         % readCode - read a length vlue code.  First reads the
        % code length and then reads a byte array of the specified length.
        % Output:
        % code - normally a uint8 array containing the code. -1 if EOD was
        % encountered before anything was read.  Error string if there was
        % an error or EOD encountered after something was read.
        % cnt - Number of bytes read.
        
        function [code, cnt] = readCode(obj, max_cnt)
            [len, cnt] = obj.readUInt();
            if ischar(len) || len==-1
                code = len;
                return;
            end
            if nargin == 2 && max_cnt < len+cnt
                code = 'EOD in the middle of value array';
                return;
            end
            code = obj.read(len);
            if isa(code, 'uint8')
                cnt = cnt + len;
                if ~isrow(code)
                    code = code';
                end
            elseif ~ischar(code)
              code = 'EOD while reading';
            end
        end
        
        % readString - read a string
        % Output:
        % str - normally the string which was read. -1 if EOD was
        %       encountered before anything was read. 0 if another error
        %       occurred, in which case the error message is returned in
        %       err_msg.
        % cnt - Number of bytes read.
        % err_msg - If not empty, the error message;
        
        function [str, cnt, err_msg] = readString(obj, max_cnt)
          err_msg = [];
          [data, cnt] = obj.readCode(max_cnt);
          if ischar(data)
            err_msg = data;
            str = 0;
          elseif ~isa(data, 'uint8')
            str = -1;
          else
            str = char(data);
          end
        end
        
    end  % methods
        
    methods(Static)
      function src = constructCodeSource(spec)
        % Create a CodeSource object.
        %
        % This function creates a single CodeSource object based on
        % specification.
        %   Input:
        %     spec - specficiation of the object(s) to create. It can be
        %     one of:
        %       - A character string, in which case a CodeSourceFile is
        %         created with spec as its file name
        %       - A struct, in which case a CodeSourcetTCP or a
        %         CodeSourceFile is created, based on the content of of the
        %         struct.
        %       - A cell array of specification. If one of the contains of a
        %         CodeSourceTCP specification, a CodeSourceTCP is created
        %         based on the first cell containing such a specification.
        %         Otherwise, a CodeSourceFile is created based on spec{1}.
        %   Output
        %     dest - a  CodeSource object 
        %
        
        if iscell(spec)
          for k=1:numel(spec)
            spc = spec{k};
            if isstruct(spc) && isfield(spc,'addr')
              src = CodeSource.constructCodeSource(spc);
              return
            end
          end
          src = CodeSource.constructCodeSource(spec{1});
          return
        elseif isa(spec, 'CodeSource')
          src = spec;
        elseif ischar(spec)
          src = CodeSourceFile(spec);
        else
          timeout = zeros(1,2);
          if ~(isfield(spec,'sndr_is_srvr') && spec.sndr_is_srvr)
            if isfield(spec,'cnct_timeout')
              timeout(1) = spec.cnct_timeout;
            end
          else
            timeout(1) = -1;
          end
          
          if isfield(spec,'recv_timeout')
            timeout(2) =  spec.recv_timeout;
          end
          src = CodeSourceTCP(timeout, spec.addr);
        end
      end
    end
    
    methods (Access=protected, Abstract)
        % Read a sequence of bytes which contains a specified number of
        % bytes < 128 and return the seuqence and the indices.
        % Input:
        %    obj - this object
        %    max_cnt - (optional) maximal number of byte to read.
        %    nseq - number of bytes which are < 128
        % Output:
        %    buf - Output buffer (uint8)
        %          -1 if EOD was encountered before any byte was read. An 
        %          error string if an error occurred or if EOD was 
        %          encountered after some bytes were read or if max_cnt was 
        %          exceeded.
        %    indcs - indices of the bytes < 128 (row vector of nseq entries)
        %    cnt - Number of bytes read.
        [buf, indcs, cnt] = readSeqs(obj, max_cnt, nseq)
    end
    
    methods (Static, Access=protected)
        function val = compSeqs(buf, indcs, bgn)
            lng = indcs-bgn;
            mx = max(lng);
            sx = (1:length(bgn))';
            
            val = uint64(buf(bgn));
            for k=1:mx
                sx = sx(lng(sx)>=k);
                val(sx) = val(sx)*uint64(128) + uint64(buf(bgn(sx)+k));
            end
        end
    end
end

