function [llc_code,qm] = CSQuantize(y, coding_info, cs_file)
  %CSQuantize quantizes the measurement vector y, according to the parameters in
  %  coding_info and returs and then lossless codes the quantized measurements.
  %  INPUT:
  %    y: A measurements vector
  %    coding_info: A parameters struct generated by getImageCodingInfo()
  %    cs_file: (optional) If present and not empty, this is a name of a file 
  %       to write the quantized measurements into.
  %  OUTPUT:
  %    llc_code: Array of bytes (uint8) which contains the lossless code.
  %    qm: A QuantMeasurements objects, which contains the output of the
  %        quantizer before lossless coding.

  % Sort no clip:
  y = coding_info.sens_mtrx.sortNoClip(y);
  
  % Quantize measurements
  qntzr = coding_info.quantizer;
  n_no_clip = qntzr.q_params.n_no_clip;
  qm = qntzr.quantizeBlk(y(1:n_no_clip), y(n_no_clip+1:end), [1,1,1]); 
  
  % lossles coding
  if nargin >= 2 && ~isempty(cs_file)
    fdst = CodeDestFile(cs_file); % create compressed measurement file
    dst = { fdst };
  else
    fdst = [];
    dst = {};
  end
  if nargout >= 1
    adst = CodeDestArray();
    dst = [dst {adst}];
  end
  
  if ~isempty(dst)
    cnt = coding_info.enc_opts.write(coding_info, dst, false);
    if ischar(cnt)
      error('QMeasuremnts:write', 'Failed writing options: %s', cnt);
    end
    cnt = qm.write(coding_info, dst, false);  % Channel coding of measurements into file
    if ischar(cnt)
      error('QMeasuremnts:write', 'Failed writing measurement: %s', dst_cnt);
    end
    
    if nargout >= 1
      llc_code = adst.getArray();
    end
    if ~isempty(fdst)
      clear fdst;
    end
  end
end

