function analyze_img_slct_hist_type(img_dir, fig_num, cnstrnts, by_qstep, lims, orig_dir,...
    show_jpg2000)
  % analyze_img analyzes statistics files generated by run_quant_test and
  % test_quant_set.
  %   img_dir: the output directory, with results file. 
  %   img_num: If a non-cell scalar, figure number for first picture, incremented
  %       sequentially, otherwise an array of figure numbers or figure handles
  %       to use for each picture.
  %   cnstrnts: a struct or array of structs sepcifying which type of results to
  %             plot (only results that match at least one struct in cnstrnts).
  %             To specify no constraints enter struct().
  %   by_qustep: true - SSIM ver. number of byte, parameterized by quantization 
  %                     step (default).
  %              false - SSIM ver. number of byte, parameterized by compression
  %                      ratio
  %  lims:  if present a struct with optional fields xlim and/or ylim, which
  %         specify the range of the figures. Otherwise the range is determined
  %         automatically.
  %  orig_dir: (optional): The directory where the original picture is. If
  %             specified, JPEG performance is also drawn.
  %  show_jpg2000: If true and orig_dir is present, show also JPEG2000 performance.
  
  if nargin < 4
    by_qstep = true;
  end
  if nargin < 5
    lims = struct();
  end
  if nargin < 6
    orig_dir = '';
  end
  if nargin < 7
    show_jpg2000 = ~isempty(orig_dir);
  end
  
  [~,img_name,~] = fileparts(img_dir);
  
  load(fullfile(img_dir, 'results.mat'), 'stats','enc_opts');
  
   enc_opts = arrayfun(@(x) getImageEncOptsStruct(x{1}), enc_opts); %#ok
  
  if nargin >= 3
    use_enc = false(size(enc_opts));
    for k =1:numel(enc_opts)
      for j=1:numel(cnstrnts)
        if iscell(cnstrnts)
          ok = chk_analyze_cnstrnt(enc_opts(k), cnstrnts{j});
        else
          ok = chk_analyze_cnstrnt(enc_opts(k), cnstrnts(j));
        end
        if ok
          use_enc(k) = true;
          break;
        end
      end
    end
    
    enc_opts = enc_opts(use_enc);
    stats = stats(use_enc);   %#ok
    
  end
  
  fig = figure(fig_num);
  clf;
  
  hold on
  
  if by_qstep
    fig_name = [img_name ' - by quant. step'];
  else
    fig_name = [img_name ' - by compressive ratio'];
  end
  title(fig_name);
  fig.Name = fig_name;
  fig.Units = 'pixels';
  fig.OuterPosition = [100,100,1000,800];
  
  q_step = unique([enc_opts(:).qntzr_wdth_mltplr]);
  q_step = sort(q_step(:),1,'descend');
  if length(q_step) > 1
    q_step_name = @(k) sprintf('q%.1f',q_step(k));
  else
    q_step_name = @(k) '';
  end
  
  csr = unique([enc_opts(:).msrmnt_input_ratio]);
  csr = sort(csr); 
  if length(csr) > 1
    csr_name = @(k) sprintf('r%03d',csr(k)*1000);
  else
    csr_name = @(k) '';
  end
  
  hst_type_names = {'HT=Gaus', 'HT=Full', 'HT=Flex', 'HT=MLTI'};
  hst_type = unique([enc_opts(:).lossless_coder_AC_hist_type]);
  if length(hst_type) > 1
    hst_type_name = @(k) hst_type_names{k+1};
  else
    hst_type_name = @(k) '';
  end
  
  smtrx = arrayfun(@(x) {[get_matrix_type(x) '-' get_matrix_args(x)]},...
    enc_opts(:));
  smtrx = smtrx(:)';
  smtrx_type = regexprep(smtrx, '-.*$','');
  smtrx_shr = regexp(smtrx, 'row_share[:](\[[^\[]*\])', 'match', 'once');
  smtrx_mrt = regexp(smtrx, 'min_row_ratio[:](\[[^\[]*\])', 'match', 'once');
  sns_mtrx = unique(smtrx);
  sns_mtrx_type = unique(regexprep(sns_mtrx, '-.*$',''));
  sns_mtrx_shr = unique(regexp(sns_mtrx, 'row_share[:](\[[^\[]*\])', 'match', 'once'));
  sns_mtrx_mrt = unique(regexp(sns_mtrx, 'min_row_ratio[:](\[[^\[]*\])', 'match', 'once'));
  if length(sns_mtrx) > 1
    sns_mtrx_name = sns_mtrx;
    k=0;
    while length(unique(arrayfun(@(x) {x{1}(end-k)}, sns_mtrx_name))) == 1
      k = k+1;
    end
    sns_mtrx_name = arrayfun(@(x)...
      {regexprep(regexprep(x{1}(1:end-k),'min_row_ratio','Rrat'),'row_share','Rshr')}, ...
      sns_mtrx_name);
  else
    sns_mtrx_name = {''};
  end
  
  q_ampl = cell(length(sns_mtrx),1);
  for k=1:length(sns_mtrx)
    opts = enc_opts(strcmp(smtrx, sns_mtrx{k}));
    q_ampl{k} = unique([opts(:).qntzr_ampl_stddev]);
    q_ampl{k} = sort(q_ampl{k},'descend');
  end
  q_ampl_name = @qAmplName;
  
  q_save = unique([enc_opts(:).qntzr_outrange_action]);
  if length(q_save) == 1
    q_save_name = {''};
  else
    q_save = sort(q_save, 'ascend');
    q_save_name = {'sF','sT'};
  end
  
  function nm = qAmplName(k,m)
    if length(q_ampl{k}) > 1
      nm = ['a', num2str(q_ampl{k}(m))];
    else
      nm = '';
    end
  end
  
  clrs = {'b','g','r', 'y', 'c'};
  mrkrs = {'x', '^', '+', 's' 'd', 'o'};
  ldash = {'-', '--'};
  lnspec = @(idx) '';
  dashspec = @(idx) ...
    ldash{1+mod(find(strcmp(sns_mtrx_type,smtrx_type{idx}),1)-1,length(ldash))};
  shrspec = @(idx) ...
    clrs{1+mod(find(strcmp(sns_mtrx_shr, smtrx_shr{idx}),1)-1,length(clrs))};
  if false
    mrtspec = @(idx) ...
      mrkrs{1+mod(find(strcmp(sns_mtrx_mrt, smtrx_mrt{idx}),1)-1,length(mrkrs))};
  else
    mrtspec = @(idx) '';
  end

  
  for imtrx=1:length(sns_mtrx)
    l_indx=0;
    lmtrx_spc = [dashspec(imtrx) shrspec(imtrx) mrtspec(imtrx)];
     
    for isv=1:length(q_save)
      for iht = 1:length(hst_type);
        for iampl=1:length(q_ampl{imtrx})
          if by_qstep
            for iratio=1:length(csr)
              indx = find(...
                strcmp(smtrx,sns_mtrx(imtrx)) & ...
                [enc_opts(:).lossless_coder_AC_hist_type] == hst_type(iht) & ...
                [enc_opts(:).qntzr_outrange_action] == q_save(isv) & ...
                [enc_opts(:).qntzr_ampl_stddev] == q_ampl{imtrx}(iampl) & ...
                [enc_opts(:).msrmnt_input_ratio] == csr(iratio) ...
                );
              sm = [stats(indx).img_ssim];
              nb = [stats(indx).n_byte];
              [nb,ind] = sort(nb);
              sm = sm(ind);
              
              l_indx = l_indx+1;
              lspc = [lmtrx_spc lnspec(l_indx)];
              lname = {sns_mtrx_name{imtrx}, q_save_name{isv}, ...
                q_ampl_name(imtrx,iampl), hst_type_name(iht), csr_name(iratio), };
              lname = strjoin(lname, ';');
              lname = regexprep(lname, '[;][;]*',';');
              lname = regexprep(lname, '[;]$','');
              if isempty(lname)
                lname = 'CS';
              end
              plot(nb,sm, lspc, 'DisplayName', lname);
            end
          else
            for istep=1:(length(q_step))
              indx = find(...
                strcmp(smtrx,sns_mtrx(imtrx)) & ...
                [enc_opts(:).lossless_coder_AC_hist_type] == hst_type(iht) & ...
                [enc_opts(:).qntzr_outrange_action] == q_save(isv) & ...
                [enc_opts(:).qntzr_ampl_stddev] == q_ampl{imtrx}(iampl) & ...
                [enc_opts(:).qntzr_wdth_mltplr] == q_step(istep));
              sm = [stats(indx).img_ssim];
              nb = [stats(indx).n_byte];
              [nb,ind] = sort(nb);
              sm = sm(ind);
              
              l_indx = l_indx+1;
              lspc = [lmtrx_spc mrkrs{l_indx} 'b'];
              lname = {sns_mtrx_name{imtrx}, q_save_name{isv} ...
                q_ampl_name(imtrx,iampl), hst_type_name(iht), q_step_name(istep)};
              lname = strjoin(lname, ';');
              lname = regexprep(lname, '[;][;]*',';');
              lname = regexprep(lname, '[;]$','');
              if isempty(lname)
                lname = 'CS';
              end
              plot(nb,sm, lspc, 'DisplayName', lname);
            end
          end
        end
      end
    end
  end
  
  if ~isempty(orig_dir)
    % guess original file name
    exts = {'.tif', '.png', 'gif', '.bmp'};
    orig_file = '';
    for k=1:length(exts)
      o_file = fullfile(orig_dir, [img_name exts{k}]);
      if exist(o_file, 'file')
        orig_file = o_file;
        break;
      end
    end
    if isempty(orig_file)
      error('No original file found for %s in %s', img_name, orig_dir);
    end
    [jpg_bytes, jpg_ssim] = getJPEG_qual(orig_file);
    plot(jpg_bytes, jpg_ssim, 'k-', 'LineWidth', 2.0, 'DisplayName', 'JPEG');
    if show_jpg2000
      [j2000_bytes, j2000_ssim] = getJPEG2000_qual(orig_file);
      plot(j2000_bytes, j2000_ssim, 'k-.', 'LineWidth', 2.0, 'DisplayName', 'JPEG2000');
    end
  end
  if isfield(lims, 'xlim')
    xlm = lims.xlim;
  else
    xlm = [min([stats(:).n_byte]),max([stats(:).n_byte])];
    if ~isempty(orig_dir)
      xlm = [min(xlm(1), min(jpg_bytes)), max(xlm(2), max(jpg_bytes))];
      if show_jpg2000
        xlm = [min(xlm(1), min(j2000_bytes)), max(xlm(2), max(j2000_bytes))];
      end
    end
  end
  if isfield(lims, 'ylim')
    ylm = lims.ylim;
  else
    ylm = [min([stats(:).img_ssim]),max([stats(:).img_ssim])];
    if ~isempty(orig_dir)
      ylm = [min(ylm(1), min(jpg_ssim)), max(ylm(2), max(jpg_ssim))];
      if show_jpg2000
        ylm = [min(ylm(1), min(j2000_ssim)), max(ylm(2), max(j2000_ssim))];
      end
    end
  end
  ylabel('SSIM'); xlabel('file size (bytes)'); xlim(xlm); ylim(ylm);
  grid on; grid minor;
  lgnd = legend('show','Location','southeast');
  lgnd.Interpreter = 'none';
  lgnd.FontSize = 10;
end
