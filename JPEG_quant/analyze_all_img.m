function analyze_all_img(out_dir, opts, cnstrnts)
  % analyze_all_img analyzes statistics files generated by run_quant_test and
  % test_quant_set.
  %
  % The program generates a Matlab figure for each processed image
  % INPUT:
  %   out_dir: the output directory, where for each picture
  %             there is a subdirectory with picture names. 
  %   opts: A struct containing various options
  %     img_num: If a non-cell scalar, figure number for first picture, incremented
  %              sequentially, otherwise an array of figure numbers or figure handles
  %              to use for each picture. If not present arbitrary new
  %              figures are generated.
  %     mode: 1 - SSIM ver. number of byte, parameterized by quantization step.
  %           2 - SSIM ver. number of byte, parameterized by compression ratio
  %           3 - Msrs. quantization error RMS to msrs RMS ratio (db). ver. number
  %               of bits per used measurement, parameterized by quantization step
  %           If not specified or empty, using 2 as the default.
  %     lims:  if present and non-empty a struct with optional fields xlim and/or 
  %           ylim, which specify the range of the figures. Otherwise the range is 
  %           determined automatically.
  %     orig_dir: (optional): The directory where the original picture is. If
  %               specified, JPEG performance is also drawn.
  %     show_jpg2000: If true and orig_dir is present, show also JPEG2000 performance.
  %     props: a struct with the following optional fields, the value of
  %            which are encoding or decoding property names.
  %                'C' - indicates color
  %                'D' - indicates dashednes of line
  %                'M' - indicates markers on line
  %     crv_specs: a struct which specifies the options for curve drawing. The
  %          optional fields are 'C' (color), 'D' (dashing), and 'M'
  %          (marker). The value of of each of these optiona fields is a
  %          struct with the following optional fields:
  %             str: a string specification, e.g. 'g' (green) or ':'
  %                  (dotted).
  %             kv: keyword-value specification. The value of this field is
  %                 a struct, where each fieldname is a name of a curve
  %                 property (e.g. 'LineWidth') and the value is the value
  %                 of this property.
  %     fig_file: If present and not empty save figure into this file with
  %               extension '.fig'.
  %
  %   cnstrnts: a struct or array of structs sepcifying which type of results to
  %             plot (only results that match at least one struct in cnstrnts).
  %             To specify no constraints enter struct(). or [].
  
  slct_opts = struct();
  if ~isfield(opts, 'img_num')
    opts.img_num = [];
  end
  if ~isfield(opts, 'mode')
    opts.mode = 2;
  end
  slct_opts.mode = opts.mode;
  slct_opts.by_qstep = (opts.mode == 1);
  if isfield(opts, 'lims')
    slct_opts.lims = opts.lims;
  else
    slct_opts.lims = struct();
  end
  if isfield(opts, 'orig_dir')
    slct_opts.orig_dir = opts.orig_dir;
  end
  if isfield(opts, 'show_jpg2000')
    slct_opts.show_jpg2000 = opts.show_jpg2000;
  end
  if ~isfield(opts, 'fig_file')
    prll = false;
    opts.fig_file = '';
    slct_opts.fig_file = '';
  else
    slct_opts.fig_file = [opts.fig_file '.fig'];
    prll = ~isempty(gcp('nocreate'));
  end
  if ~isfield(opts, 'props')
    opts.props = struct();
  end
  slct_opts.props = opts.props;
  
 if isfield(opts,'crv_specs')
   slct_opts.crv_specs = opts.crv_specs;
 end
  
  if nargin < 3 || isempty(cnstrnts)
    cnstrnts = struct();
  end
  
  dr = dir(out_dir);
  dr = dr([dr.isdir] & ~strcmp({dr.name},'.') & ~ strcmp({dr.name},'..'));
  
  if isempty(opts.img_num)
    img_ids = cell(size(dr));
  elseif iscell(opts.img_num)
    img_ids = opts.img_num;
  elseif isscalar(opts.img_num)
    img_ids = num2cell(opts.img_num: (opts.img_num + length(dr) - 1));
  else
    img_ids = num2cell(opts.img_num);
  end
  
  if prll
    parfor k=1:length(dr)
      img_dir = fullfile(out_dir, dr(k).name);
      img_id = img_ids{k};
      s_opts = slct_opts;
      s_opts.img_num = img_id;
      fig_hndl = [];  %#ok prevent warnings about 
      switch(s_opts.mode)
        case 1
          fig_hndl = analyze_img_slct(img_dir, s_opts, cnstrnts);
        case 2
          fig_hndl = analyze_img_slct(img_dir, s_opts, cnstrnts);
        case 3
          fig_hndl = analyze_qmsr_slct(img_dir,  img_id, cnstrnts, s_opts.lims);
        otherwise
          error('Unexpected mode: %d', mode);
      end
      if ~isempty(s_opts.fig_file)
        savefig(fig_hndl, fullfile(img_dir, s_opts.fig_file));
      end
    end
    for k=1:length(dr)
      img_dir = fullfile(out_dir, dr(k).name);
      openfig(fullfile(img_dir, [opts.fig_file '.fig']));
    end
  else
    for k=1:length(dr)
      img_dir = fullfile(out_dir, dr(k).name);
      img_id = img_ids{k};
      s_opts = slct_opts;
      s_opts.img_num = img_id;
      switch(s_opts.mode)
        case 1
          fig_hndl = analyze_img_slct(img_dir,  s_opts, cnstrnts);
        case 2
          fig_hndl = analyze_img_slct(img_dir,  s_opts, cnstrnts);
        case 3
          fig_hndl = analyze_qmsr_slct(img_dir,  img_id, cnstrnts, s_opts.lims);
        otherwise
          error('Unexpected mode: %d', mode);
      end
      if ~isempty(s_opts.fig_file)
        savefig(fig_hndl, fullfile(img_dir, s_opts.fig_file));
      end
    end
  end
end