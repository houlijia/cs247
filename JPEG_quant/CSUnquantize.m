function [qy, coding_info,  sat_ind, qm] = ...
    CSUnquantize( src, ref )
  %CSUnquantize Unquantizes compressive sensing measurements
  %  INPUT
  %    src: A file name containg the compressed measurements or a QuantMeasurements
  %         object, or a byte (uint8) array containing the code
  %    ref: An optional argument for debugging. If present and not zero it
  %         should be a struct containing enc_opts and qm generated in
  %         quantization and it verifies that they are identical to the outputs
  %         coding_info.enc_opts and qm, respectively.
  %  OUTPUT
  %    qy: vector of unquantized measurements
  %    coding_info: A parameters struct as generated by getImageCodingInfo
  %    sat_ind: indices of the entries in qy which are satutrated. These
  %      entries are set to 0 in qy.
  %   qm: QuantMeasurements objects containing the measurements and related
  %       information.
  %   q_max_err - maximal quantization error
  %   q_stddev_err - estimated standard deviation of quantization error
  
  if nargin < 2
    ref = struct();
  end
  if ischar(src)
    source = CodeSourceFile(src);  % Open compressed measurements file fo input
  else
    source = CodeSourceArray(src);
  end
  
  enc_opts = CS_EncImgParams();
  cnt = enc_opts.read([], source);
  if ischar(cnt)
    error('QMeasuremnts:readElement', 'Failed reading options: %s', cnt);
  end
  if isfield(ref, 'enc_opts') && ~ref.enc_opts.isEqual(enc_opts)
    error('QMeasuremnts:readElement', 'Incorrect enc_opts');
  end
  coding_info = compCodingInfo(enc_opts);
 
  qm = QuantMeasurements();
  cnt = qm.read(coding_info, source);
  if ischar(cnt)
    error('QMeasuremnts:readElement', 'Failed reading measurement from: %s', cnt);
  end
  if isfield(ref, 'qm') && ~isEqual(ref.qm, qm)
    error('QMeasuremnts:readElement', 'Incorrect QuantMeaurement');
  end
  
 [qy, sat_ind, intvl] = coding_info.quantizer.unquantize(qm);
 qy = coding_info.sens_mtrx.unsortNoClip(qy);
 coding_info.sens_mtrx.setZeroedRows(sat_ind);
 
 coding_info.q_max_err = intvl / 2;
 coding_info.q_stddev_err = intvl / sqrt(12);  % Assuming uniform distribution in each bin
  
end

