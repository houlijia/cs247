function [fig, fig_name] = analyze_img_slct(img_dir, opts, cnstrnts)
  % analyze_img analyzes statistics files generated by run_quant_test and
  % test_quant_set.
  %   img_dir: the output directory, with results file. 
  %   opts: A struct containing various options
  %     img_num: Figure number of figure handle. If missing a new figure is
  %              created.
  %     by_qstep: true - SSIM ver. number of byte, parameterized by quantization 
  %                     step .
  %               false - SSIM ver. number of byte, parameterized by compression
  %                      ratio(default).
  %     lims:  if present a struct with optional fields xlim and/or ylim, which
  %            specify the range of the figures. Otherwise the range is determined
  %            automatically.
  %     orig_dir: (optional): The directory where the original picture is. If
  %             specified, JPEG performance is also drawn. default: true  
  %     show_jpg2000: If true and orig_dir is present, show also JPEG2000 performance.
  %     
  %     props: a struct with the following optional fields, the value of
  %            which are encoding or decoding property names.
  %                'C' - indicates color
  %                'D' - indicates dashednes of line
  %                'M' - indicates markers on line
  %     crv_specs: a struct which specifies the options for curve drawing. The
  %          optional fields are 'C' (color), 'D' (dashing), and 'M'
  %          (marker). The value of of each of these optiona fields is a
  %          struct with the following optional fields:
  %             str: a string specification, e.g. 'g' (green) or ':'
  %                  (dotted).
  %             kv: keyword-value specification. The value of this field is
  %                 a struct, where each fieldname is a name of a curve
  %                 property (e.g. 'LineWidth') and the value is the value
  %                 of this property.
  %
  %   cnstrnts: a struct or array of structs sepcifying which type of results to
  %             plot (only results that match at least one struct in cnstrnts).
  %             To specify no constraints enter struct().
  %
  % OUTPUT:
  %   fig: handle to the figure
  %   fig_name: name of the figure
  
  if ~isfield(opts, 'fig_num')
    opts.fig_num = [];
  end
  if ~isfield(opts, 'by_qstep')
    opts.by_qstep = false;
  end
  if ~isfield(opts, 'lims')
    opts.lims = struct();
  end
  if ~isfield(opts, 'orig_dir')
    opts.orig_dir = '';
  end
  if ~isfield(opts, 'show_jpg2000')
    opts.show_jpg2000 = true;
  end
  if ~isfield(opts, 'props')
    opts.props = struct();
  end
  
  crv_specs = struct(...
    'C', struct('str', {'b','g','r', 'c'}, 'kv',struct()),...
    'M', struct('str', {'x', '^', '+', 's' 'd', 'o', 'v','p'},...
                'kv',struct('MarkerSize', 8)),...
    'D', struct('str', {'-', '--', ':'}, ...
                 'kv', {struct('LineWidth', 0.8), struct('LineWidth', 1.0),....
                        struct('LineWidth', 1.5)}) ...
    );

  if isfield(opts, 'crv_specs')
    crv_specs_flds = fieldnames(crv_specs);
    for if0 = 1:length(crv_specs_flds)
      ff0 =  crv_specs_flds{if0};
      if ~isfield(opts.crv_specs, ff0)
        continue;
      end
      crv_specs.(ff0) = opts.crv_specs.(ff0);
    end
  end

  if nargin < 3
    cnstrnts = struct();
  end
  
  [~,img_name,~] = fileparts(img_dir);
  
  try
    fname = fullfile(img_dir, 'results.mat');
    load(fname, 'stats','enc_opts', 'dec_opts');
  catch excpt
    fprintf('*** Failed reading stats from %s: %s\n',...
      fname, excpt.message);
    return
  end
  
  dec_opts = arrayfun(@(x) x{1}, dec_opts); %#ok
  dec_opts = removeCommonFields(dec_opts);
  
  enc_opts = arrayfun(@(x) getImageEncOptsStruct(x{1}), enc_opts); %#ok
  enc_opts = removeCommonFields(enc_opts);

  show_str_prms = struct('cell_marked', true, 'struct_marked',true, 'struct_sep', ';');
  if nargin >= 3
    cnstrnts_str = show_str(cnstrnts, struct(), show_str_prms);
    cnstrnts_str = edit_enc_str(cnstrnts_str);
    if ~isempty(cnstrnts_str)
      cnstrnts_str = [' - ' cnstrnts_str];
    end
    
    use_enc = false(size(enc_opts));
    for k =1:numel(enc_opts)
      for j=1:numel(cnstrnts)
        if iscell(cnstrnts)
          ok = chk_analyze_cnstrnt(enc_opts(k), cnstrnts{j});
        else
          ok = chk_analyze_cnstrnt(enc_opts(k), cnstrnts(j));
        end
        if ok
          use_enc(k) = true;
          break;
        end
      end
    end
    
    enc_opts = enc_opts(use_enc);
    enc_opts = removeCommonFields(enc_opts);
    stats = stats(use_enc,:);   %#ok
    
  else
    cnstrnts_str = '';
  end
  
  if opts.by_qstep
    crv_enc_opts = rmfield(enc_opts, 'qntzr_wdth_mltplr');
    fig_name = [img_name cnstrnts_str ' - by quant. step'];
  else
    crv_enc_opts = rmfield(enc_opts, 'msrmnt_input_ratio');
    fig_name = [img_name cnstrnts_str ' - by compressive ratio'];
  end
  
  new_curve = true(size(enc_opts));
  crv_enc_indcs = cell(size(enc_opts));
  for k=1:numel(crv_enc_opts)
    for j=1:k-1
      if isEqual(crv_enc_opts(k), crv_enc_opts(j))
        new_curve(k) = false;
        crv_enc_indcs{j} = [crv_enc_indcs{j} k];
        break;
      end
    end
    if new_curve(k)
      crv_enc_indcs{k} = k;
    end
  end
  crv_enc_opts = crv_enc_opts(new_curve);
  crv_enc_indcs = crv_enc_indcs(new_curve);
  
  crv_enc_name = cell(size(crv_enc_opts));
  for k=1:numel(crv_enc_opts)
    crv_enc_name{k} = show_str(crv_enc_opts(k), struct(), show_str_prms);
    crv_enc_name{k} = edit_enc_str(crv_enc_name{k});
  end
%  crv_enc_name = removeCommonHeadTail(crv_enc_name);
  
  function enc_str = edit_enc_str(enc_str)
    enc_str = regexprep(enc_str, 'struct<', '<');
    enc_str = regexprep(enc_str, 'qntzr_wdth_', 'qw_');
    enc_str = regexprep(enc_str, 'qntzr_', 'q_');
    enc_str = regexprep(enc_str, 'msrmnt_input_ratio', 'R');
    enc_str = regexprep(enc_str, 'msrmnt_mtrx', 'mtx');
    enc_str = regexprep(enc_str, ' ', '');
  end
  
  dec_name = cell(size(dec_opts));
  for k=1:numel(dec_opts)
    dec_name{k} = show_str(dec_opts(k), struct(), show_str_prms);
  end
  
  curve_line = cell(numel(crv_enc_opts),numel(dec_opts));
  
  % Handle props
  prop_spec_names = fieldnames(opts.props);
  
  % These structs will have the same fields as opts.props.
  prop_rng = struct();  % cell array of property unique values
  prop_enc = struct();  % true if the property is encoder property, 
                        % false for decoder property
  prop_spec = struct(); % will have values copied from crv_specs
  
  for ie=1:length(prop_spec_names)
    ff = prop_spec_names{ie};
    fv = opts.props.(ff);
    if isfield(crv_enc_opts, fv)
      prop_enc.(ff) = true;
      vals = {crv_enc_opts.(fv)};
    elseif isfield(dec_opts, ff)
      prop_enc.(ff) = false;
      vals = {dec_opts.(fv)};
    else
      opts.props = rmfield(opts.props, ff);
      continue;
    end
    
    vals_new = true(size(vals));
    for ie0=2:numel(vals)
      for ie1=1:(ie0-1)
        if vals_new(ie1) && isEqual(vals(ie0), vals(ie1))
          vals_new(ie0) = false;
          break;
        end
      end
    end
    vals = vals(vals_new);
    prop_rng.(ff) = vals;
    prop_spec.(ff) = crv_specs.(ff);
    crv_specs = rmfield(crv_specs, ff);
  end 
  prop_spec_names = fieldnames(opts.props);
  
  % prop_list is a struct array with the same fields as opts.props. The
  % values are indices into prop_rng. Each struct of the array has one
  % combination of values. 
  rng_dim = zeros(1, length(prop_spec_names));
  for ie=1:length(prop_spec_names)
    ff = prop_spec_names{ie};
    rng_dim(ie) = length(prop_rng.(ff));
  end
  prop_list = cell(prod(rng_dim), length(prop_spec_names));
  for ie=1:length(prop_spec_names)
    u = ones(prod(rng_dim(1:ie-1)),1) * (1:rng_dim(ie));
    u = u(:) * ones(1, prod(rng_dim(ie+1:end)));
    prop_list(:,ie) = num2cell(u(:));
  end
  prop_list = cell2struct(prop_list, prop_spec_names, 2);
  
  % prop_crv_spec is a struct array of the same length as prop_list,
  % containing the line specfication for each combination.
  prop_crv_spec = struct('str', cell(size(prop_list)), 'kv', struct());
  for k=1:length(prop_list)
    for ie=1:length(prop_spec_names)
      ff = prop_spec_names{ie};
      prop_crv_spec(k) = get_curve_line(prop_list(k).(ff)-1, ...
        struct(ff, {prop_spec.(ff)}), prop_crv_spec(k));
    end
  end
  
  idx = zeros(size(prop_list));
  for k=1:numel(crv_enc_opts)
    for j=1:numel(dec_opts)
      for h=1:length(prop_list)
        mtch = true;
        for ie=1:length(prop_spec_names)
          ff = prop_spec_names{ie};
          pr = opts.props.(ff);
          rng = prop_rng.(ff);
          rng_val = rng{prop_list(h).(ff)};
          if prop_enc.(ff)
            mtch = isEqual(rng_val, crv_enc_opts(k).(pr));
          else
            mtch = isEqual(rng_val, dec_opts(j).(pr));
          end
          if ~mtch
            break;
          end
        end
        if ~mtch
          continue;
        end
        
        curve_line{k,j} = get_curve_line(idx(h), crv_specs, prop_crv_spec(h));
        idx(h) = idx(h) + 1;
        break;
      end
    end
  end
  
  function crvln = get_curve_line(idx, lprp, crvln_base)
    crvln = crvln_base;
    flds = fieldnames(lprp);
    step = 1;
    for i=1:length(flds)
      fld = flds{i};
      p = length(lprp.(fld));
      str_fld = {lprp.(fld).str};
      crvln.str = [crvln.str str_fld{mod(floor(idx/step),p)+1}];
      prp_kv = [lprp.(fld).kv];
      kv_flds = fieldnames(prp_kv);
      for ikv=1:length(kv_flds)
        kv_fld = kv_flds{ikv};
        crvln.kv.(kv_fld) = prp_kv(mod(floor(idx/step),p)+1).(kv_fld);
      end
      step = step * p;
    end
  end

  if ~isempty(opts.fig_num)
    fig = figure(opts.fig_num);
  else
    fig = figure();
  end
  clf;
  
  hold on
  
  title(fig_name, 'Interpreter', 'none');
  fig.Name = fig_name;
  fig.Units = 'pixels';
  fig.OuterPosition = [100,100,1000,800];
  
  for ienc=1:numel(crv_enc_opts)
    for idec=1:numel(dec_opts)
      sm = [stats(crv_enc_indcs{ienc},idec).img_ssim];
      nb = [stats(crv_enc_indcs{ienc},idec).n_byte];
      [nb,ind] = sort(nb);
      sm = sm(ind);
      
      crv_name = [crv_enc_name(ienc),dec_name(idec)];
      non_empt = arrayfun(@(x) ~isempty(x{1}), crv_name);
      crv_name = crv_name(non_empt);
      crv_name = strjoin(crv_name, '-');
      if isempty(crv_name)
        crv_name = 'CS';
      end
      
      hcrv = plot(nb, sm, curve_line{ienc, idec}.str, 'DisplayName', crv_name);
      crv_kv = curve_line{ienc, idec}.kv;
      crv_kv_flds = fieldnames(crv_kv);
      for ikv_fld = 1:length(crv_kv_flds)
        crv_kv_fld = crv_kv_flds{ikv_fld};
        hcrv.(crv_kv_fld) = crv_kv.(crv_kv_fld);
      end
        
    end
  end
  
%   q_step = unique([enc_opts(:).qntzr_wdth_mltplr]);
%   q_step = sort(q_step(:),1,'descend');
%   if length(q_step) > 1
%     q_step_name = @(k) sprintf('q%.2g',q_step(k));
%   else
%     q_step_name = @(k) '';
%   end
%   
%   csr = unique([enc_opts(:).msrmnt_input_ratio]);
%   csr = sort(csr); 
%   if length(csr) > 1
%     csr_name = @(k) sprintf('r%03d',csr(k)*1000);
%   else
%     csr_name = @(k) '';
%   end
%   
%   if isfield(enc_opts, 'msrmnt_mtrx')
%     smtrx = arrayfun(@(x) {[get_matrix_type(x) '-' get_matrix_args(x)]},...
%       enc_opts(:));
%     smtrx = smtrx(:)';
%     smtrx_type = regexprep(smtrx, '-.*$','');
%     smtrx_shr = regexp(smtrx, 'row_share[:](\[[^\[]*\])', 'match', 'once');
%     smtrx_mrt = regexp(smtrx, 'min_row_ratio[:](\[[^\[]*\])', 'match', 'once');
%     sns_mtrx = unique(smtrx);
%     sns_mtrx_type = unique(regexprep(sns_mtrx, '-.*$',''));
%     sns_mtrx_shr = unique(regexp(sns_mtrx, 'row_share[:](\[[^\[]*\])', 'match', 'once'));
%     sns_mtrx_mrt = unique(regexp(sns_mtrx, 'min_row_ratio[:](\[[^\[]*\])', 'match', 'once'));
%     if length(sns_mtrx) > 1
%       sns_mtrx_name = sns_mtrx;
%       k=0;
%       while length(unique(arrayfun(@(x) {x{1}(end-k)}, sns_mtrx_name))) == 1
%         k = k+1;
%       end
%       sns_mtrx_name = arrayfun(@(x)...
%         {regexprep(regexprep(x{1}(1:end-k),'min_row_ratio','Rrat'),'row_share','Rshr')}, ...
%         sns_mtrx_name);
%     else
%       sns_mtrx_name = {''};
%     end
%   else
%     sns_mtrx_name = {''};
%   end
%   
%   if isfield(enc_opts, 'qntzr_ampl_stddev');
%     q_ampl = cell(length(sns_mtrx),1);
%     for k=1:length(sns_mtrx)
%       opts = enc_opts(strcmp(smtrx, sns_mtrx{k}));
%       q_ampl{k} = unique([opts(:).qntzr_ampl_stddev]);
%       q_ampl{k} = sort(q_ampl{k},'descend');
%     end
%     q_ampl_name = @qAmplName;
%   else
%     q_ampl_name = {''};
%   end
%   
%   if isfield(enc_opts, 'qntzr_outrange_action')
%     q_save = unique([enc_opts(:).qntzr_outrange_action]);
%     q_save = sort(q_save, 'ascend');
%     q_save_name = {'sF','sT'};
%   else
%     q_save_name = {''};
%   end
%   
%   function nm = qAmplName(k,m)
%     if length(q_ampl{k}) > 1
%       nm = ['a', num2str(q_ampl{k}(m))];
%     else
%       nm = '';
%     end
%   end
%   
%   shrspec = @(idx) ...
%     clrs{1+mod(find(strcmp(sns_mtrx_shr, smtrx_shr{idx}),1)-1,length(clrs))};
%   mrtspec = @(idx) ...
%     mrkrs{1+mod(find(strcmp(sns_mtrx_mrt, smtrx_mrt{idx}),1)-1,length(mrkrs))};
%   
%   for imtrx=1:length(sns_mtrx)
%     l_indx=0;
%     lmtrx_spc = [dashspec(imtrx) shrspec(imtrx) mrtspec(imtrx)];
%     for idec = 1:length(dec_opts)
%       
%       for isv=1:length(q_save)
%         for iampl=1:length(q_ampl{imtrx})
%           if opts.by_qstep
%             for iratio=1:length(csr)
%               indx = find(...
%                 strcmp(smtrx,sns_mtrx(imtrx)) & ...
%                 [enc_opts(:).qntzr_outrange_action] == q_save(isv) & ...
%                 [enc_opts(:).qntzr_ampl_stddev] == q_ampl{imtrx}(iampl) & ...
%                 [enc_opts(:).msrmnt_input_ratio] == csr(iratio));
%               sm = [stats(indx, idec).img_ssim];
%               nb = [stats(indx, idec).n_byte];
%               [nb,ind] = sort(nb);
%               sm = sm(ind);
%               
%               l_indx = l_indx+1;
%               lspc = [lmtrx_spc lnspec(l_indx)];
%               lname = [sns_mtrx_name{imtrx} q_save_name{isv} ...
%                 q_ampl_name(imtrx,iampl) csr_name(iratio)];
%               if isempty(lname)
%                 lname = 'CS';
%               end
%               if length(dec_opts) > 1
%                 lname = sprintf('%s~%d', lname, idec);
%               end
%                 
%               plot(nb,sm, lspc, 'DisplayName', lname);
%             end
%           else
%             for istep=1:(length(q_step))
%               indx = find(...
%                 strcmp(smtrx,sns_mtrx(imtrx)) & ...
%                 [enc_opts(:).qntzr_outrange_action] == q_save(isv) & ...
%                 [enc_opts(:).qntzr_ampl_stddev] == q_ampl{imtrx}(iampl) & ...
%                 [enc_opts(:).qntzr_wdth_mltplr] == q_step(istep));
%               sm = [stats(indx, idec).img_ssim];
%               nb = [stats(indx, idec).n_byte];
%               [nb,ind] = sort(nb);
%               sm = sm(ind);
%               
%               l_indx = l_indx+1;
%               lspc = [lmtrx_spc lnspec(l_indx)];
%               lname = [sns_mtrx_name{imtrx} q_save_name{isv} ...
%                 q_ampl_name(imtrx,iampl) q_step_name(istep)];
%               if isempty(lname)
%                 lname = 'CS';
%               end
%               if length(dec_opts) > 1
%                 lname = sprintf('%s~%d', lname, idec);
%               end
%               
%               plot(nb,sm, lspc, 'DisplayName', lname);
%             end
%           end
%         end
%       end
%     end
%   end
  
  if ~isempty(opts.orig_dir)
    % guess original file name
    exts = {'.tif', '.png', 'gif', '.bmp'};
    orig_file = '';
    for k=1:length(exts)
      o_file = fullfile(opts.orig_dir, [img_name exts{k}]);
      if exist(o_file, 'file')
        orig_file = o_file;
        break;
      end
    end
    if isempty(orig_file)
      error('No original file found for %s in %s', img_name, opts.orig_dir);
    end
    [jpg_bytes, jpg_ssim] = getJPEG_qual(orig_file);
    plot(jpg_bytes, jpg_ssim, 'k-', 'LineWidth', 2.0, 'DisplayName', 'JPEG');
    if opts.show_jpg2000
      [j2000_bytes, j2000_ssim] = getJPEG2000_qual(orig_file);
      plot(j2000_bytes, j2000_ssim, 'k-.', 'LineWidth', 2.0, 'DisplayName', 'JPEG2000');
    end
  end
  if isfield(opts.lims, 'xlim')
    xlm = opts.lims.xlim;
  else
    xlm = [min([stats(:).n_byte]),max([stats(:).n_byte])];
    if ~isempty(opts.orig_dir)
      xlm = [min(xlm(1), min(jpg_bytes)), max(xlm(2), max(jpg_bytes))];
      if opts.show_jpg2000
        xlm = [min(xlm(1), min(j2000_bytes)), max(xlm(2), max(j2000_bytes))];
      end
    end
  end
  if isfield(opts.lims, 'ylim')
    ylm = opts.lims.ylim;
  else
    ylm = [min([stats(:).img_ssim]),max([stats(:).img_ssim])];
    if ~isempty(opts.orig_dir)
      ylm = [min(ylm(1), min(jpg_ssim)), max(ylm(2), max(jpg_ssim))];
      if opts.show_jpg2000
        ylm = [min(ylm(1), min(j2000_ssim)), max(ylm(2), max(j2000_ssim))];
      end
    end
  end
  ylabel('SSIM'); xlabel('file size (bytes)'); xlim(xlm); ylim(ylm);
  grid on; grid minor;
  lgnd = legend('show','Location','southeast');
  lgnd.Interpreter = 'none';
  lgnd.FontSize = 10;

  
%   function strngs = removeCommonHeadTail(strngs)
%     % strngs is a cell array of strings
%     ks=0;
%     while true
%       try
%         s = arrayfun(@(x) {x{1}(end-ks)}, strngs);
%       catch
%         break;
%       end
%       if length(unique(s)) > 1
%         break;
%       end
%       ks = ks+1;
%     end
%     strngs = arrayfun(@(x) {x{1}(1:end-ks)}, strngs);
%     
%     ks=1;
%     while true
%       try
%         s = arrayfun(@(x) {x{1}(ks)}, strngs);
%       catch
%         break;
%       end
%       if length(unique(s)) > 1
%         break;
%       end
%       ks = ks+1;
%     end
%     strngs = arrayfun(@(x) {x{1}(ks:end)}, strngs);
%   end
  
end
